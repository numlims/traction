# traction main

main is a little traction cli.

``//__main__.py:
``import``
``add_args``
``getidc``
``datespan``
``lof``

``main``

sys.exit(main())
``

main holds a cli for traction. it takes a database target and
various search flags. see `traction -h`.

``/main:
def main():
    ``.``
``

get the settings before starting traction for setting up idcontainer flags.

``
    try:
        settings = cnf.makeload(path=".traction/settings.yaml", root=cnf.home, fmt="yaml", make=tr.cnftemplate)        
    except cnf.MakeCnfException as e:
        print("traction: " + str(e))
        return 1
``

for now, if no settings, do nothing.

``
    if settings == None:
        return
``      

parse the arguments.

``
    parser = argparse.ArgumentParser()

    # in any case take the database target
    parser.add_argument("db", help="db target")

    parser.add_argument("what", help="sample|patient|trial|finding|method|user|catalog|usageentry|name. finding: messbefund; method: messprofil; name: get display names for a table.") # labval: messparameter
    parser.add_argument("--sampleid", help="sampleid(s)")
    parser.add_argument("--patientid", help="patientid(s)")
    parser.add_argument("--sidc", help="patient idcontainer. overrides sampleid in settings.yaml")    
    parser.add_argument("--pidc", help="patient idcontainer. overrides patientid in settings.yaml")
    parser.add_argument("--parentid", help="sampleid(s) of parent samples")    
    parser.add_argument("--trial", help="trial code(s)")
    parser.add_argument("--locationpath", help="locationpath(s)")
    parser.add_argument("--kitid", help="kitid(s)")
    parser.add_argument("--cxxkitid", help="cxxkitid(s)")
    parser.add_argument("--category", help="MASTER|DERIVED|ALIQUOTGROUP")
    parser.add_argument("--type", help="sample type (material)")
    parser.add_argument("--orga", help="organisation unit")
    parser.add_argument("--sampling-date", help="sampling date from:to")
    parser.add_argument("--receipt-date", help="receipt date from:to")
    parser.add_argument("--derival-date", help="derival date from:to")    
    parser.add_argument("--first-reposition-date", help="first reposition date from:to")
    parser.add_argument("--reposition-date", help="reposition date from:to")
    parser.add_argument("--stockprocessing-date", help="first stock processing date from:to")
    parser.add_argument("--secondprocessing-date", help="second stock processing date from:to")
    parser.add_argument("--primary-ref", help="reference the primary of each derived, without including it", action="store_true")    
    parser.add_argument("--parents", help="include parents starting from the root", action="store_true")
    parser.add_argument("--childs", help="include the childs up to the leafs", action="store_true")
    parser.add_argument("--tree", help="include the whole tree for each sample", action="store_true")            
    parser.add_argument("--method", help="labormethod(s) (messprofil)")
    parser.add_argument("--catalog", help="catalog(s))")    
    parser.add_argument("--table", help="the table to get names for codes for")
    parser.add_argument("--ml-table", help="if the table mapping from codes to in mytable to names is not called centraxx_mytable_ml_name, give its name here.")
    parser.add_argument("--username", help="the username of user(s).")
    parser.add_argument("--email", help="the email address of user(s).")                
    parser.add_argument("--last-login", help="the date of the user's last login.")
    parser.add_argument("--verbose", help="comma-separated tr constants that should be joined in, e.g. 'patientid,locationpath'") # -v?  nargs=1?
    parser.add_argument("--verbose-all", help="join in all additional info, takes longer", action="store_true") # -a?
    parser.add_argument("--names", help="add display names", action="store_true") 
    parser.add_argument("--like", help="comma seperated list of tr constants where to check for like instead of equal")
    parser.add_argument("--files", help="comma seperated list for which flags files are passed")
    parser.add_argument("--missing", help="get missing. not yet implemented.", action="store_true") # -m?
    parser.add_argument("--order-by", help="order by on sql query level")
    parser.add_argument("--top", help="first n results on sql query level")    
    parser.add_argument("--query", help="print the query", action="store_true")
    parser.add_argument("--raw", help="return raw results", action="store_true")
    parser.add_argument("--csv", help="write results to csv file or to stdout", default=None, const=True, nargs="?") # if `--csv file` is passed, args.csv is file, if only --csv is passed, args.csv is True (const), if no --csv flag is passed, args.csv is None (default).
    parser.add_argument("-D", help="csv output delimiter, default comma")
    parser.add_argument("--delim-cmp", help="delimiter of multi and catalog lists in csv output")
``

add idc flags from settings.

``
    add_args(parser, settings)
``

parse all arguments.

``
    args = parser.parse_args()

    # print(args.verbose)
    # print(args)
``

split the verbose array.

``
    verbose = []
    if args.verbose != None:
        verbose = args.verbose.split(",")
``

start up traction.

``
    try:
        traction = tr.traction(args.db)
``

intercept target error.

``
    except TargetException as e: # is this referencable from other packages?
        print("traction: " + str(e))
        return 1
``

find out what flags should be read from file, apart from the f:
mechanism.

``
    files = None
    if args.files is not None:
        files = args.files.split(",")
``

either read the flag arguments as comma seperated lists or collect
them in filemap.

``
    filemap = {}
    sampleids = lof(tr.sampleid, args.sampleid, files, filemap)
    parentids = lof(tr.parentid, args.parentid, files, filemap)
    patientids = lof(tr.patientid, args.patientid, files, filemap)
    trials = lof(tr.trial, args.trial, files, filemap)
    locationpaths = lof(tr.locationpath, args.locationpath, files, filemap)
    methods = lof(tr.method, args.method, files, filemap)
    catalogs = lof(tr.catalog, args.catalog, files, filemap)    
    kitids = lof(tr.kitid, args.method, files, filemap)
    cxxkitids = lof(tr.cxxkitid, args.cxxkitid, files, filemap)
    categories = lof(tr.category, args.category, files, filemap)
    types = lof(tr.type, args.type, files, filemap)    
    orgas = lof(tr.orga, args.orga, files, filemap)
    usernames = lof(tr.username, args.username, files, filemap)
    emails = lof(tr.email, args.email, files, filemap)
    #print(filemap)
``

read like as comma seperated list.

``
    likes = None
    if args.like:
        likes = args.like.split(",")
``

get sample(s).

encode the json with jsonpickle to render the class attributes,
json.dumps doesn't do that.

also include the @property functions when rendering json, to quickly
get to the sampleid. todo doesn't work.

``
    if args.what == "sample":
        sample = traction.sample(
               #sampleids=sampleids,
               idc=getidc(vars(args), settings),
               parentids=parentids,
               patientids=patientids,
               pidc=args.pidc,
               trials=trials,
               locationpaths=locationpaths,
               kitids=kitids,
               cxxkitids=cxxkitids,
               categories=categories,
               types=types,
               orgas=orgas,
               samplingdates=datespan(args.sampling_date),
               receiptdates=datespan(args.receipt_date),
               derivaldates=datespan(args.derival_date),
               first_repositiondates=datespan(args.first_reposition_date),
               repositiondates=datespan(args.reposition_date),
               stockprocessingdates=datespan(args.stockprocessing_date),
               secondprocessingdates=datespan(args.secondprocessing_date),
               #files={ tr.sampleid: "/home/max/awb_tools/awb_prep/murdi/sampleids-test.txt" }, # makefilesmap(args)
               files=filemap,
               verbose=verbose,
               verbose_all=args.verbose_all,
               primaryref=args.primary_ref,
               incl_parents=args.parents,
               incl_childs=args.childs,
               incl_tree=args.tree,
               like=likes,
               missing=args.missing,
               order_by=args.order_by,
               top=args.top,
               print_query=args.query,
               raw=args.raw)
               
        if args.csv is not None:
            if args.csv is True:
                #file = sys.stdout # todo fix
                file = True
            else:
                file = args.csv
            outfile = tr.idable_csv(sample, file, delim=args.D) # rename csv?
            if isinstance(outfile, str):
                print(outfile)
        else:
            print(jsonpickle.encode(sample, unpicklable=False, indent=4)) # somehow include_properties=True doesn't work
``

unpicklable=False to renders dates and seems to make the json output
generally neater.

get patient(s).

``
    elif args.what == "patient":
        patients = traction.patient(patientids=patientids,
            pidc=args.pidc,
            sampleids=sampleids,
            idc=getidc(vars(args), settings),
            trials=trials,
            orgas=orgas,
            files=filemap,
            verbose=verbose,
            verbose_all=args.verbose_all,
            like=likes,
            order_by=args.order_by,
            top=args.top,
            print_query=args.query,
            raw=args.raw)
        #print(json.dumps(patients, default=str))
        print(jsonpickle.encode(patients, unpicklable=False, indent=4))
``

get trial(s).

``
    elif args.what == "trial":
        res = traction.trial()
        print(json.dumps(res, default=str, indent=4))
``

get method(s) and their labvals.

``
    elif args.what == "method":
        res = traction.method(methods=methods, files=filemap)
        print(json.dumps(res, default=str, indent=4))
``

get finding(s) and their recorded values.

``
    elif args.what == "finding":
        res = traction.finding(sampleids=sampleids,
            patientids=patientids,
            pidc=args.pidc,
            idc=getidc(vars(args), settings),
            methods=methods,
            trials=trials,
            files=filemap,
            values=True, # todo make arg?
            names=args.names,
            top=args.top,
            print_query=args.query,
            verbose_all=args.verbose_all,
            raw=args.raw)
            
        if args.csv is not None:
            if args.csv is True:
                #file = sys.stdout
                file = True
            else:
                file = args.csv
            outfile = tr.finding_csv(res, file, delim=args.D, delim_cmp=args.delim_cmp) 
            if isinstance(outfile, str):
                print(outfile)
        else:
            print(jsonpickle.encode(res, unpicklable=False, indent=4))
        #print(json.dumps(res, default=str, indent=4))
``

get user(s).

``
    elif args.what == "user":
        res = traction.user(username=usernames, emails=emails, lastlogin=datespan(args.last_login), files=filemap, verbose=verbose)
        print(jsonpickle.encode(res, unpicklable=False, indent=4))
``

get catalog entries.

``
    elif args.what == "catalog":
        res = traction.catalog(catalogs=catalogs, files=filemap)
        print(jsonpickle.encode(res, unpicklable=False, indent=4))
``

get usageentries.

``
    elif args.what == "usageentry":
        res = traction.usageentry()
        print(jsonpickle.encode(res, unpicklable=False, indent=4))
``

get a name.

``
    elif args.what == "name":
        # res = traction.name("laborfinding")
        res = traction.name(args.table, args.ml_table)
        print(json.dumps(res, default=str, indent=4))
``

if what is unrecognized  give an error.

``
    else:
        print(f"error: {args.what} not recognized. see traction -h.")
        return 1
``

import.

``/import:
import argparse
import cnf
from dbcq import dbcq
from dbcq import TargetException
import tr
import simplejson as json
import sys
import jsonpickle
``

lof (list or file) either reads arguments passed to a flag as comma
seperated list or collects them in filemap if the argument is
proceeded with f:.  if the files array is passed (from the --files
flag), all params given in it are collected as file, and all others
are read as comma seperated list, irrespective of f:.

if the flag was not set, None is returned.

``/lof:
def lof(name:str, passed, files:list=None, filemap:dict=None):
    ``.``
``

if the value passed is none and it is listed in files give an error,
else just return None.

``
    if passed is None:
        if files is not None and name in files:
            raise Exception(f"error: {name} is listed in --files, please pass a file path to --{name}")
        else:
            return None
``


if files array is given, and this name is in files, collect it as file, else
read it as comma seperated list, ignoring f:

join the current working directory to the filepath.

``
    if files is not None:
        if name in files:
            filemap[name] = os.path.join(os.getcwd(), passed)
            return None
        else:
            return passed.split(",")
``

if files is not given, collect file if the string that was passed is preceeded
with f:, else read it as comma seperated list.

``
    else:
        res = re.subn(r'^f:', '', passed)
        if res[1] > 0: # count
            filemap[name] = os.path.join(os.getcwd(), res[0]) # the substituted string
        else:
            return passed.split(",")
``

import.

``/import
import os
import os.path
``

if no files flag is passed, read the params starting with f: as
filenames and the others as comma seperated list.

add_args adds idc args from settings.

``/add_args:
def add_args(parser, settings):
    for item in settings["idc"]:
        parser.add_argument(f"--{item.lower()}", required=False, help=f"{item} idcontainer")
``

getidc filters the arg flags according to the idcs given in settings.

``/getidc:
def getidc(args:dict, settings):
    ``.``
``

search in lower case cause the flags are lower case, return in in
whichever case it is in settings["idc"].

``
    out = {}
    for item in settings["idc"]:

      if item.lower() in args and args[item.lower()] != None:
        out[item] = args[item.lower()].split(",")
    return out
``

datespan turns a passed date argument like
`%YYYY-%mm-%dd:%YYY-%mm-%dd` to a tuple of two dates. also just one
date can be passed, it needs to be preceeded by `=`, `>=` or `<=`,
then just the first or second element of the tuple is set.  also
'NULL' can be passed, in this case not a tuple is retuned, but just
the 'NULL' string.

``/datespan:
def datespan(datestr:str, format:str="%Y-%m-%d"):
    ``.``
``

return None on None.

``
    if datestr is None:
        return None
``

return 'NULL' on 'NULL'.

``
    if datestr == 'NULL':
        return 'NULL'
``

check for leading greater equal, less equal or equal.

if greater than only put in the first tuple member.

subn returns a tuple of changed string and number of replacements
made.

``
    res = re.subn(r'^>=', '', datestr)
    if res[1] > 0:
        dfrom = datetime.strptime(res[0], format)
        return (dfrom, None)
``

if less than only put in the second tuple member.

``
    res = re.subn(r'^<=', '', datestr)
    if res[1] > 0:
        dto = datetime.strptime(res[0], format)
        return (None, dto)
``

if equal put in the date for both tuple members.

``
    res = re.subn(r'^=', '', datestr)
    if res[1] > 0:
        d = datetime.strptime(res[0], format)
        return (d, d)
``

split on the colon.

``
    a = datestr.split(":")
``

allow start or end date to be left out, but require the colon.

``
    if len(a) != 2:
       raise Exception("date needs to be in format >=from, <=to, =date or from:to.")
``

parse the dates.

``
    dfrom = None
    dto = None
    dfrom = datetime.strptime(a[0], format)
    dto = datetime.strptime(a[1], format)
``

return tuple.

``
    return (dfrom, dto)
``

import for datespan.

``/import
import re
from datetime import datetime
``