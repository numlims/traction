# main is a little traction cli

``//__main__.py:
``import``
``add_args``
``getidc``
``datespan``
``lfpof``
``lff``

``main``


sys.exit(main())
``

main holds a cli for traction. it takes a database target and
various search flags. see `traction -h`.

``/main:
def main():
    ``.``
``

get the settings before starting traction for setting up idcontainer flags.

``
    try:
        settings = cnf.makeload(path=".traction/settings.yaml", root=cnf.home, fmt="yaml", make=tr.cnftemplate)        
    except cnf.MakeCnfException as e:
        print("traction: " + str(e))
        return 1
``

for now, if no settings, do nothing.

``
    if settings == None:
        return
``      

parse the arguments.

``
    parser = argparse.ArgumentParser()

    # in any case take the database target
    parser.add_argument("db", help="db target")

    parser.add_argument("what", help="sample|patient|trial|finding|method|user|name. finding: messbefund; method: messprofil; name: get display names for a table.") # labval: messparameter
    parser.add_argument("--sampleid", help="sampleid(s)")
    parser.add_argument("--patientid", help="patientid(s)")
    parser.add_argument("--parentid", help="sampleid(s) of parent samples")    
    parser.add_argument("--trial", help="trial code(s)")
    parser.add_argument("--locationpath", help="locationpath(s)")
    parser.add_argument("--kitid", help="kitid(s)")
    parser.add_argument("--cxxkitid", help="cxxkitid(s)")
    parser.add_argument("--category", help="MASTER|DERIVED|ALIQUOTGROUP")
    parser.add_argument("--orga", help="organisation unit")
    parser.add_argument("--sampling-date", help="sampling date from:to")
    parser.add_argument("--receipt-date", help="receipt date from:to")
    parser.add_argument("--derival-date", help="derival date from:to")    
    parser.add_argument("--first-reposition-date", help="first reposition date from:to")
    parser.add_argument("--reposition-date", help="reposition date from:to")
    parser.add_argument("--stockprocessing-date", help="first stock processing date from:to")
    parser.add_argument("--secondprocessing-date", help="second stock processing date from:to")
    parser.add_argument("--primary-ref", help="reference the primary of each derived, without including it", action="store_true")    
    parser.add_argument("--parents", help="include parents starting from the root", action="store_true")
    parser.add_argument("--childs", help="include the childs up to the leafs", action="store_true")
    parser.add_argument("--tree", help="include the whole tree for each sample", action="store_true")            
    parser.add_argument("--method", help="labormethod(s) (messprofil)")
    parser.add_argument("--table", help="the table to get names for codes for")
    parser.add_argument("--ml-table", help="if the table mapping from codes to in mytable to names is not called centraxx_mytable_ml_name, give its name here.")
    parser.add_argument("--username", help="the username of user(s).")
    parser.add_argument("--email", help="the email address of user(s).")                
    parser.add_argument("--last-login", help="the date of the user's last login.")
    parser.add_argument("--verbose", help="comma-separated tr constants that should be joined in, e.g. 'patientid,locationpath'") # -v?  nargs=1?
    parser.add_argument("--verbose-all", help="join in all additional info, takes longer", action="store_true") # -a?
    parser.add_argument("--like", help="comma seperated list of tr constants where to check for like instead of equal")
    parser.add_argument("--files", help="comma seperated list for which flags files are passed")
    parser.add_argument("--missing", help="get missing. not yet implemented.", action="store_true") # -m?
    parser.add_argument("--where", help="additional sql where string")
    parser.add_argument("--order-by", help="order by on sql query level")
    parser.add_argument("--top", help="first n results on sql query level")    
    parser.add_argument("--query", help="print the query", action="store_true")
    parser.add_argument("--raw", help="return raw results", action="store_true")
    parser.add_argument("--csv", help="write results to csv file")
``

add idc flags from settings.

``
    add_args(parser, settings)
``

parse all arguments.

``
    args = parser.parse_args()

    # print(args.verbose)
    # print(args)
``

split the verbose array.

``
    verbose = []
    if args.verbose != None:
        verbose = args.verbose.split(",")
``

start up traction.

``
    try:
        traction = tr.traction(args.db)
``

intercept target error.

``
    except TargetException as e: # is this referencable from other packages?
        print("traction: " + str(e))
        return 1
``

find out what flags should be read from file, apart from the f:
mechanism.

``
    files = None
    if args.files is not None:
        files = args.files.split(",")
``

read the flags, either as comma seperated list or from file path.

``
    sampleids = lfpof(tr.sampleid, args.sampleid, files)
    parentids = lfpof(tr.parentid, args.parentid, files)
    patientids = lfpof(tr.patientid, args.patientid, files)
    trials = lfpof(tr.trial, args.trial, files)
    locationpaths = lfpof(tr.locationpath, args.locationpath, files)
    methods = lfpof(tr.method, args.method, files)
    kitids = lfpof(tr.kitid, args.method, files)
    cxxkitids = lfpof(tr.cxxkitid, args.cxxkitid, files)
    categories = lfpof(tr.category, args.category, files)
    orgas = lfpof(tr.orga, args.orga, files)
    usernames = lfpof(tr.username, args.username, files)
    emails = lfpof(tr.email, args.email, files)        
``

read like as comma seperated list.

``
    likes = None
    if args.like:
        likes = args.like.split(",")
``

get a sample.

encode the json with jsonpickle to render the class attributes,
json.dumps doesn't do that.

also include the @property functions when rendering json, to quickly
get to the sampleid. todo doesn't work.

``
    if args.what == "sample":
        sample = traction.sample(
               sampleids=sampleids,
               idc=getidc(vars(args), settings),
               parentids=parentids,
               patientids=patientids,
               trials=trials,
               locationpaths=locationpaths,
               kitids=kitids,
               cxxkitids=cxxkitids,
               categories=categories,
               orgas=orgas,
               samplingdates=datespan(args.sampling_date),
               receiptdates=datespan(args.receipt_date),
               derivaldates=datespan(args.derival_date),
               first_repositiondates=datespan(args.first_reposition_date),
               repositiondates=datespan(args.reposition_date),
               stockprocessingdates=datespan(args.stockprocessing_date),
               secondprocessingdates=datespan(args.secondprocessing_date),
               verbose=verbose,
               verbose_all=args.verbose_all,
               primaryref=args.primary_ref,
               incl_parents=args.parents,
               incl_childs=args.childs,
               incl_tree=args.tree,
               like=likes,
               missing=args.missing,
               where=args.where,
               order_by=args.order_by,
               top=args.top,
               print_query=args.query,
               raw=args.raw)
               
        if args.csv is not None:
            outfile = tr.idable_csv(sample, args.csv) # rename csv?
            if outfile is not None:
                print(outfile)
        else:
            print(jsonpickle.encode(sample, unpicklable=False, indent=4)) # somehow include_properties=True doesn't work
``

unpicklable=False to renders dates and seems to make the json output
generally neater.

get a patient.

``
    elif args.what == "patient":
        patients = traction.patient(patientids=patientids,
            sampleids=sampleids,
            idc=getidc(vars(args), settings),
            trials=trials,
            orgas=orgas,
            verbose=verbose,
            verbose_all=args.verbose_all,
            like=likes,
            order_by=args.order_by,
            top=args.top,
            print_query=args.query,
            raw=args.raw)
        #print(json.dumps(patients, default=str))
        print(jsonpickle.encode(patients, unpicklable=False, indent=4))
``

get a trial.

``
    elif args.what == "trial":
        res = traction.trial()
        print(json.dumps(res, default=str, indent=4))
``

get method(s) and their labvals.

``
    elif args.what == "method":
        res = traction.method(methods=methods)
        print(json.dumps(res, default=str, indent=4))
``

get a finding.

``
    elif args.what == "finding":
        res = traction.finding(sampleids=sampleids,
            patientids=patientids,
            idc=getidc(vars(args), settings),
            methods=methods,
            trials=trials,
            values=True, # todo make arg?
            print_query=args.query,
            verbose_all=args.verbose_all,
            raw=args.raw)
        print(jsonpickle.encode(res, unpicklable=False, indent=4))
        #print(json.dumps(res, default=str, indent=4))
``

get user(s)

``
    elif args.what == "user":
        res = traction.user(username=usernames, emails=emails, lastlogin=datespan(args.last_login), verbose=verbose)
        print(jsonpickle.encode(res, unpicklable=False, indent=4))
``


get a name.

``
    elif args.what == "name":
        # res = traction.name("laborfinding")
        res = traction.name(args.table, args.ml_table)
        print(json.dumps(res, default=str, indent=4))
``

if what is unrecognized  give an error.

``
    else:
        print(f"error: {args.what} not recognized. see traction -h.")
        return 1
``

import.

``/import:
import argparse
import cnf
from dbcq import dbcq
from dbcq import TargetException
import tr
import simplejson as json
import sys
import jsonpickle
``

lfpof (list from param or file) reads values passed to a flag as comma
seperated list or from file if the value is proceeded with f:.  if the
files flag is passed, all params given to it are read from file, and
all others as comma seperated list, irrespective of f:.

if the flag was not set, None is returned.

``/lfpof:
def lfpof(name:str, passed, files:list=None):
    ``.``
``

if the value passed is none and it is listed in files give an error,
else just return None.

``
    if passed is None:
        if files is not None and name in files:
            raise Exception(f"error: {name} is listed in --files, please pass a file path to --{name}")
        else:
            return None
``


if files is given, and this name is in files, read it as file, else
read it as comma seperated list, ignoring f:

``
    if files is not None:
        if name in files:
            return lff(passed)
        else:
            return passed.split(",")
``

if files is not given, read from file if passed string is preceeded
with f:, else as comma seperated list.

``
    else:
        res = re.subn(r'^f:', '', passed)
        if res[1] > 0: # count
            return lff(res[0])
        else:
            return passed.split(",")
``

if no files flag is passed, read the params starting with f: as
filenames and the others as comma seperated list.

lff (list from file) reads the contents of a file and returns them as
list by line.

``/lff:
def lff(path):
    ``.``
``

open the file and read, return it's contents split on newline.

``
    with open(path) as f:
        return f.read().split("\n") 
``


add_args adds idc args from settings.

``/add_args:
def add_args(parser, settings):
    for item in settings["idc"]:
        parser.add_argument(f"--{item.lower()}", required=False, help=f"{item} idcontainer")
``

getidc filters the arg flags according to the idcs given in settings.

``/getidc:
def getidc(args:dict, settings):
    ``.``
``

search in lower case cause the flags are lower case, return in in
whichever case it is in settings["idc"].

``
    out = {}
    for item in settings["idc"]:

      if item.lower() in args and args[item.lower()] != None:
        out[item] = args[item.lower()].split(",")
    return out
``

datespan turns a passed date argument like
`%YYYY-%mm-%dd:%YYY-%mm-%dd` to a tuple of two dates. also just one
date can be passed, it needs to be preceeded by `=`, `>=` or `<=`,
then just the first or second element of the tuple is set.  also
'NULL' can be passed, in this case not a tuple is retuned, but just
the 'NULL' string.

``/datespan:
def datespan(datestr:str, format:str="%Y-%m-%d"):
    ``.``
``

return None on None.

``
    if datestr is None:
        return None
``

return 'NULL' on 'NULL'.

``
    if datestr == 'NULL':
        return 'NULL'
``

check for leading greater equal, less equal or equal.

if greater than only put in the first tuple member.

subn returns a tuple of changed string and number of replacements
made.

``
    res = re.subn(r'^>=', '', datestr)
    if res[1] > 0:
        dfrom = datetime.strptime(res[0], format)
        return (dfrom, None)
``

if less than only put in the second tuple member.

``
    res = re.subn(r'^<=', '', datestr)
    if res[1] > 0:
        dto = datetime.strptime(res[0], format)
        return (None, dto)
``

if equal put in the date for both tuple members.

``
    res = re.subn(r'^=', '', datestr)
    if res[1] > 0:
        d = datetime.strptime(res[0], format)
        return (d, d)
``

split on the colon.

``
    a = datestr.split(":")
``

allow start or end date to be left out, but require the colon.

``
    if len(a) != 2:
       raise Exception("date needs to be in format >=from, <=to, =date or from:to.")
``

parse the dates.

``
    dfrom = None
    dto = None
    dfrom = datetime.strptime(a[0], format)
    dto = datetime.strptime(a[1], format)
``

return tuple.

``
    return (dfrom, dto)
``

import for datespan.

``/import
import re
from datetime import datetime
``