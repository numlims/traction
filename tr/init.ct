# traction

commonly used getters (and setters?) for centrax db.

``//__init__.py: #py
``import``
``const``

``_checkverbose``
``floatornull``
``get_ids``

``identifier class``
``amount class``
``idable class``
``sample class``
``patient class``
``finding class``

``rec``
``booleanrec``
``numberrec``
``stringrec``
``daterec``
``catalogrec``
``multirec``

``idable_csv``

class traction:
    ``init``

    ``sample``
    ``_get_parents``
    ``_get_childs``
    ``patient``
    ``trial``
    ``finding``
    ``method``
    ``name``
    ``sidc``
    ``pidc``

    ``_selectstr``
    ``_joinstr``
    ``_append_idc_select``
    ``_append_idc_join``
    ``_where``
    ``_wherebuild``
    ``_sqlinplaceholder``
    ``_whereparam``
    ``_wherelike``
    ``_wherelikes``
    ``_top``
    ``_idcinit``
    ``_make_rec``
    ``_sampleidcs``
    ``_patientidcs``
    ``_concrete_idcs``
    
    ``_fill_in_primary``

``

at the package level are a series of constants that can be used in
function calls, e.g. sample(..., verbose=[tr.parentid,
tr.locationpath]).

maybe keep the names in lowercase so that they are the same as the
keys in the returned json?

``/const: #py
appointment = "appointment"
cxxkitid = "cxxkitid"
samplingdate = "samplingdate" # entnahmedatum / extraction date. 
concentration = "concentration"
derivaldate = "derivaldate" # aufteilungsdatum / date of distribution
category = "category" # MASTER, ALIQUOTGROUP, DERIVED. dtype in db.
initialamount = "initialamount"
initialunit = "initialunit"
first_repositiondate = "first_repositiondate" # datum der ersten einlagerung / date of first storage (not in fhir). is identical to derivaldate. first_repositiondate in db.
method = "method"
kitid = "kitid"
locationname = "locationname"
locationpath = "locationpath"
orga = "orga"
parentid = "parentid"
parentoid = "parentoid"
patientid = "patientid"
project = "project"
receiptdate = "receiptdate" # eingangsdatum / date of receipt. receiptdate in db.
receptacle = "receptacle"
repositiondate = "repositiondate" # datum der letzten einlagerung / most recent storage date. 
restamount = "restamount"
restunit = "restunit"
sampleid = "sampleid"
sampleoid = "sampleoid"
sampletype = "sampletype"
secondprocessing = "secondprocessing"
secondprocessingdate = "secondprocessingdate"
stockprocessing = "stockprocessing"
stockprocessingdate = "stockprocessingdate"
trial = "trial"
type = "type" # sampletype (EDTA, stool etc) in db. 
values = "values"
xposition = "xposition"
yposition = "yposition"
``

__init__ takes the db target either as string or dbcq object.

``/init: #py
    def __init__(self, target):
        ``.``
``

get the settings. if the settings file is missing, cnf creates it and
asks the user to edit it.

``
        self.settings = cnf.makeload(path=".traction/settings.yaml", root=cnf.home, fmt="yaml", make=cnftemplate)        
``

if no settings, do nothing. 

``
        if self.settings == None:
            raise Exception("no settings.")
            return
``

either pass a string argument to dbcq or use dbcq instance directly.

`` #py
        if isinstance(target, str):
            self.db = dbcq(target)
        elif isinstance(target, dbcq): 
            self.db = target
        else:
            raise Exception("target needs to be string or dbcq instance")
``

cache the id containers' oids and kinds by code.

``
        self._idcinit()
        #print(f"_idcoids: {self._idcoids}")
``

make a join-dict, jd, that holds joins from table a to table b.

init jd here, cause it needs to reference self at one point for joining in an idc_ table.

``
        self.jd = {
            ``jd sample_to``
            ,
            ``jd patient_to``
        }
``

import dbcq and cnf.

``/import: #py
from dbcq import *
import cnf
``

add a variable that holds the conf template.

``/const
cnftemplate = """
# settings for traction.

# sampleid sets the idcontainertype code that is used when searching for sampleid.
# put in a code per db target.
sampleid: 
  <db target>: <an idcontainertype code, e.g. SAMPLEID>
# patientid sets the idcontainertype code that is used when searching for patientid.
# put in a code per db target.
patientid: 
  <db target>: <an idcontainertype code, e.g. LIMSPSN>

# idc holds additional idcontainertype codes that will be queryable as command line flags.
idc:
 - <an idcontainertype code>
 - <another idcontainertype code>
"""
``

sample gets sample(s) and returns them as a list of Sample instances.

pass sampleids and other values to filter for as lists of strings,
e.g. `sampleids=["a", "b", "c"]`.

use the idc param to filter for idcontainer lists by passing a dict of
lists keyed by idcontainer code, e.g. `idc={"extsampleid": ["a", "b", "c"]}`.

put info that should be joined into the result into the verbose array,
e.g.  `verbose=[tr.locationpath]`. to join in everything, say
`verbose_all=True`. this is slower than non-verbose.

pass dates as a tuple of from and to datetime, e.g. `samplingdates=(datefrom, None)`.

to check via like as opposed to exact, put the respective fields into
the like array, e.g. `like=[tr.locationpath]`.

``/sample: #py
    def sample(self, sampleids:list=None, oids:list=None, idc=None, patientids:list=None, parentids:list=None, parentoids:list=None, locationpaths:list=None, trials:list=None, kitids:list=None, cxxkitids:list=None, categories:list=None, samplingdates=None, receiptdates=None, derivaldates=None, first_repositiondates=None, repositiondates=None, stockprocessingdates=None, secondprocessingdates=None, verbose=[], verbose_all=False, primaryref:bool=False, incl_parents:bool=False, incl_childs:bool=False, incl_tree:bool=False, like=[], missing=False, where=None, order_by=None, top=None, print_query:bool=False, raw:bool=False):
        ``.``
``

these are all possible verbose options (verbose-all-array).

let sampleid be the first element in vaa so it gets joined in first
for subsequent joins that depend on it.

`` #py
        # print("try:" + tr.sampleid)
        vaa = [cxxkitid, kitid, locationname, locationpath, orga, parentid, 
               project, receptacle, sampletype,
               secondprocessing, stockprocessing, trial]
``

append the idcs for patient and sample to the vaa array.  

``
        vaa.extend(self._patientidcs())
        vaa.extend(self._sampleidcs())                
``

always join in the sampleid for now, again, as the first array element
for subsequent joins that might need it.

`` #py
        if not self.sidc() in verbose:
            verbose.insert(0, self.sidc())
``

replace traction constants patientid and sampleid with their idc.

``
        verbose = self._concrete_idcs(verbose)
``

put the keys for the given arguments into the verbose array, so that
they land in the join, so that the wherestring can access the
joined-in fields.

`` #py
        if trials:
            verbose.append(trial)
        if locationpaths:
            verbose.append(locationpath)
        if kitids:
            verbose.append(kitid)
        if cxxkitid:
            verbose.append(cxxkitid)
        if parentids:
            verbose.append(parentid)
``

on verbose_all include all constants in the verbose array.

`` #py
        if verbose_all == True:
            verbose = vaa
``

make sure that the verbose array only contains keys from the verbose-all-array.

``
        if not _checkverbose(verbose, vaa): 
            return None # throw error?
``

after the verbose array was filled walk the sample tree if needed.

there are two cases where we walk the sample tree:

(a) including other samples.

if the sample's parents, children or it's whole tree should be
included in the result, first run this call, take the sample oids
returned, then add the oids of the parents / childs / tree samples (in
order from root to leaf), and then run the query with its verboses for
all the sample oids.

(b) referencing the primary sample for each derived sample.

if each derived sample should reference its primary, also
run the call, and then fill in the primary field for each sample.

at first it was thought to do the primary referencing via verbose, but
then each verbose all call would include the primary references, which
might slow it down?

check if we walk the sample tree.

``
        if incl_parents or incl_childs or incl_tree or primaryref:
            ``incl``
``

we fire the call with all the arguments except incl_*, and raw.

we pass only verbose if we add primary references, cause then we only
run the call once. if we include tree samples later we don't pass
verbose, cause we eventually run the call again for all tree samples,
passing verbose here would slow it down.

it shouldn't make a difference to pass verbose_all for primary, cause
verbose should be filled in any case.

``/sample/incl:
            verbosepass = []
            if primaryref:
                verbosepass = verbose
``

fire the call, then add to the result.

``
            res = self.sample(sampleids=sampleids, idc=idc, parentids=parentids, parentoids=parentoids, patientids=patientids, trials=trials, locationpaths=locationpaths, kitids=kitids, cxxkitids=cxxkitids, categories=categories, samplingdates=samplingdates, receiptdates=receiptdates, derivaldates=derivaldates, first_repositiondates=first_repositiondates, repositiondates=repositiondates, stockprocessingdates=stockprocessingdates, secondprocessingdates=secondprocessingdates, verbose=verbosepass, verbose_all=False, like=like, missing=missing, where=where, order_by=order_by, top=top, print_query=print_query)
``

proceed differently if primary info should be added or if samples from
the tree should be included.

``
            if primaryref:
                for sample in res:
                    self._fill_in_primary(sample)
                return res
``

when including samples from the tree, take all the sample oids.

use oids to support aliquotgroups.

``/sample/incl
            
            s_oids = get_ids(res, "oid")
``

withincl holds all the sampleids that eventually get queried.

``
            withincl = []
``

now put in the sample oids of parents, childs or the whole tree.

``
            for s_oid in s_oids:
               if incl_parents:
                   ``parents``
               if incl_childs:
                   ``childs``
               if incl_tree:
                   ``tree``
``

if the parent sampleids should be included, get them from root to
leaf. collect them into the pids list.

``/sample/incl/parents:
                   p_oids = []
                   self._get_parents(s_oid, p_oids)
``

put the parent oids in, followed by our sample oid.

``
                   withincl.extend(p_oids)
                   withincl.append(s_oid)
``

if the child oids should be included, get them from sample to leaf.

``/sample/incl/childs:
                  c_oids = []
                  self._get_childs(s_oid, c_oids)
``

put the child oids in, preceeded by our sample oid.

``
                  withincl.append(s_oid)
                  withincl.extend(c_oids)
``

if the whole tree should be included, get the root, and include all
children from there.

``/sample/incl/tree:
                  p_oids = []
                  self._get_parents(s_oid, p_oids)
                  if len(p_oids) > 0:
                      root = p_oids[0]
                  else:
                      root = s_oid
``

get the child oids from root.

``
                  c_oids = []
                  self._get_childs(root, c_oids)
``

append the root oid, then the child oids.

``
                  withincl.append(root)
                  withincl.extend(c_oids)
``

after filling withincl, filter out recurring sampleids. keep each id
where it first appeared in the array to preserve tree dependencies.


``/sample/incl
            withincl = list(dict.fromkeys(withincl))
``

using dict.fromkeys here depends on python dicts preserving insertion order
since python 3.7.

now run the query for all the sampleids with the verboses. the
verboses should contain all the query parameters from the original
call. in the call here we don't pass the query parameters from the
original call, cause we used them already to get the sampleids, and
here they could filter out parent/child/tree samples we'd like to keep.

``
            return self.sample(oids=withincl, verbose=verbose, print_query=print_query, raw=raw) # todo pass verbose_all?
``

put the sampleids and patientids into idc, to handle them as just
another idcontainer for joining and in where.

``/sample
        # todo check that self.sidc() is not in idc
        if idc is None:
           idc = {}
        if sampleids is not None:
           idc[self.sidc()] = sampleids
        if patientids is not None:
           idc[self.pidc()] = patientids
``

jselect holds statements for optional joins by key.

rename the field of the main sample idcontainer to sampleid.

`` #py
        jselects = {
            self.sidc(): [f"idc_{self.sidc()}.psn as '{sampleid}'"],
            self.pidc(): [f"idc_{self.pidc()}.psn as '{patientid}'"],                   
            cxxkitid: [f"samplekit.cxxkitid as '{cxxkitid}'"],
            #sampleid: [f"sidc.psn as '{sampleid}'"],
            parentid: [f"parentidc.psn as '{parentid}'"],
            kitid: [f"samplekit.kitid as '{kitid}'"],
            locationname: [f"samplelocation.locationid as '{locationname}'"], 
            locationpath: [f"samplelocation.locationpath as '{locationpath}'"],
            sampletype: [f"sampletype.code as '{sampletype}'"],
            stockprocessing: [f"stockprocessing.code as '{stockprocessing}'"],
            secondprocessing: [f"secondprocessing.code as '{secondprocessing}'"],
            project: [f"project.code as '{project}'"],
            #patientid: [f"patidc.psn as '{patientid}'"],
            receptacle: [f"receptable.code as '{receptacle}'"],
            orga: [f"organisationunit.code as '{orga}'"],
            trial: [f"flexistudy.code as '{trial}'"],
        }
``

lselects holds the local selects for this table, for field renames.

put sample.* first, that it doesn't overwrite field of the renames?

``
        lselects = [
          f"sample.amountrest as {restamount}",
          f"sample.appointmentnumber as {appointment}",
          f"sample.dtype as {category}",
          f"sample.oid as {sampleoid}",
          f"sample.parent as {parentoid}",
          "sample.*"
        ]
``

the join statements for optional joins by key. if the same join is
needed for two different keys (e.g. locationname and locationpath),
filter them out later.

pull the values from the join dict, jd.

`` #py
        joins = {
            cxxkitid: self.jd["sample_to_samplekit"],
            parentid: self.jd["sample_to_parentid"],
            kitid: self.jd["sample_to_samplekit"],
            locationname: self.jd["sample_to_samplelocation"],
            locationpath: self.jd["sample_to_samplelocation"],
            sampletype: self.jd["sample_to_sampletype"],
            stockprocessing: self.jd["sample_to_stockprocessing"],
            secondprocessing: self.jd["sample_to_secondprocessing"],
            project: self.jd["sample_to_project"],
            receptacle: self.jd["sample_to_receptacle"],
            orga: self.jd["sample_to_orga"],
            trial: self.jd["sample_to_trial"]
        }
``

for any patient idc, join in patientcontainer, which is needed by
_append_idc_joins.

``
        for pidc in self._patientidcs():
            joins[pidc] = self.jd["sample_to_patient"]
``

put together the select string and join string for the query.

`` #py
        selectstr = self._selectstr(jselects, verbose, lselects, idc)  
        joinstr = self._joinstr(joins, verbose, idc)  
``

get the where string.

`` #py
        (wherestr, whereargs) = self._where(idc=idc, sampleoids=oids, parentids=parentids, parentoids=parentoids, trials=trials, locationpaths=locationpaths, kitids=kitids, cxxkitids=cxxkitids, categories=categories, samplingdates=samplingdates, receiptdates=receiptdates, derivaldates=derivaldates, first_repositiondates=first_repositiondates, repositiondates=repositiondates, stockprocessingdates=stockprocessingdates, secondprocessingdates=secondprocessingdates, verbose=verbose, like=like, wherearg=where) 
``

get the top string.

``
        topstr = self._top(top)
``

stick together the query, get the result and return it.

`` #py
        query = f"select {topstr} {selectstr} from centraxx_sample sample \n{joinstr} \nwhere {wherestr}"
        if order_by is not None:
            query += f" order by {order_by}"
        if print_query:
           print(query)
           print(whereargs)

        res = self.db.qfad(query, whereargs)
``

if raw is wished return the raw result.

``
        if raw:
            return res
``

the first implementation tried to take the tablenames/colums as keys
for the returned json fields, but that doesn't quite work for
patientpsn, where the key would be just 'idcontainer.psn'. so for now
joined-in fields are renamed to 'sampleid', 'patientid',
'parentid' etc. // todo still true?

turn the result to samples.

``
        sarr = []
        for r in res:
            ``.``
``

collect the sample's ids.

``
            ids = []
            #if dig(r, sampleid) is not None:
            #    ids.append(Identifier(id=dig(r, sampleid), code=self.sidc()))
            for idc in self._sampleidcs():
                #print("idc:" + idc)
                #print("r:" + str(r))
                if idc.lower() in r and r[idc.lower()] is not None:
                    ids.append( Identifier(id=dig(r, idc.lower()), code=idc.upper()) )
``

include the oid.

``
            ids.append( Identifier(id=int(dig(r, sampleoid)), code="oid") ) # todo rename sampleoid?
``

reference the parent as an Idable to be able to include both oid and
sampleid. the oid is needed for aliquotgroups that don't come with an
idcontainer.

``
            pids = []
            if r[parentoid] is not None:
                pids.append(Identifier(id=int(r[parentoid]), code="oid"))
            if dig(r, parentid) is not None:
                pids.append(Identifier(id=dig(r, parentid), code=self.sidc()))
            parent = None
            if len(pids) > 0:
                parent = Idable(ids=pids, mainidc=self.sidc())
``

also reference the patient as Idable.

``
            patids = []
            if dig(r, patientid) is not None:   # todo include patient oid?
                patids.append(Identifier(id=dig(r, patientid), code=self.pidc()))
            patient = None
            if len(patids) > 0:
                patient = Idable(ids=patids, mainidc=self.pidc())
``

build the sample.

``
            s = Sample(
                appointment=dig(r, appointment),
                category=dig(r, category),
                samplingdate=dig(r, samplingdate),
                concentration=dig(r, concentration),
                cxxkitid=dig(r, cxxkitid),
                derivaldate=dig(r, derivaldate),
                ids=ids,
                initialamount=Amount(floatornull(dig(r, initialamount)), dig(r, initialunit)), # apparently the cast to float is explicitly needed
                kitid=dig(r, kitid),
                locationpath=dig(r, locationpath),
                locationname=dig(r, locationname),
                orga=dig(r, orga),
                parent=parent,
                patient=patient,
                project=dig(r, project),
                receiptdate=dig(r, receiptdate),
                receptacle=dig(r, receptacle),
                repositiondate=dig(r, repositiondate),
                restamount=Amount(floatornull(dig(r, restamount)), dig(r, restunit)),
                secondprocessing=dig(r, secondprocessing),
                secondprocessingdate=dig(r, secondprocessingdate),
                sidc=self.sidc(),
                stockprocessing=dig(r, stockprocessing),
                stockprocessingdate=dig(r, stockprocessingdate),
                trial=dig(r, trial),
                type=dig(r, sampletype),
                xposition=dig(r, xposition), 
                yposition=dig(r, yposition)
            )
            sarr.append(s)
``

buffer each fetch to r with dig, for keys that are not in r.

return.

``/sample
        return sarr
``

import.

``/import
from datetime import datetime
from dip import dig, dis
``

the joindict entries that sample needs.

``/init/jd sample_to:
            "sample_to_samplekit": [f"left join centraxx_samplekititem as samplekititem on samplekititem.tubebarcode = idc_{self.sidc()}.psn", "left join centraxx_samplekit as samplekit on samplekit.oid = samplekititem.samplekit"],
            "sample_to_parentid": [f"left join centraxx_sampleidcontainer parentidc on parentidc.sample = sample.parent and parentidc.idcontainertype={self._idcoid[self.sidc()]}"],
            "sample_to_samplelocation": ["left join centraxx_samplelocation samplelocation on samplelocation.oid = sample.samplelocation"],
            "sample_to_sampletype": ["left join centraxx_sampletype as sampletype on sampletype.oid = sample.sampletype"],
            "sample_to_stockprocessing": ["left join centraxx_stockprocessing as stockprocessing on sample.stockprocessing = stockprocessing.oid"],
            "sample_to_secondprocessing": ["left join centraxx_stockprocessing as secondprocessing on sample.secondprocessing = secondprocessing.oid"],
            "sample_to_project": ["left join centraxx_project as project on sample.project = project.oid"],
            "sample_to_patient": ["left join centraxx_patientcontainer as patientcontainer on sample.patientcontainer = patientcontainer.oid"],
            "sample_to_receptacle": ["left join centraxx_samplereceptable as receptable on sample.receptable = receptable.oid"], # receptable seems to be a typo in the table naming
            "sample_to_orga": ["left join centraxx_organisationunit as organisationunit on sample.orgunit = organisationunit.oid"],
            "sample_to_trial": ["left join centraxx_flexistudy as flexistudy on sample.flexistudy = flexistudy.oid"]
``

_get_parents collects the parent sample oids of a sample in the `out`
list, in order from root to leaf. take oids to include aliquotgroups,
they don't necessarily have an idcontainer attached to them.

``/_get_parents:
    def _get_parents(self, oid, out):
        ``.``
``

get the parent oid. query directly for performance (sample() would
join in the sampleid idcontainer by default).

``
        res = self.db.qfad("select parent from centraxx_sample where oid = ?", oid)
        pid = dig(res[0], "parent")
``

insert the parent at the front of the out array, to keep the root-to-leaf
direction.

``
        if pid is not None:
            out.insert(0, pid)
            ``.``
``

recurse to get the parent's parent.

``
            self._get_parents(pid, out)
``

_get_childs collects the oids of the sample's children in the `out`
list, in order from root-to-leaf. take oids to include aliquotgroups.

``/_get_childs:
    def _get_childs(self, oid, out):
        ``.``
``

get the children. query directly for performancs (sample() would join
in the main sample idcontainer by default).

``
        res = self.db.qfad("select oid from centraxx_sample where parent = ?", oid)
``

if there are children, append them.

``
        for child in res:
            out.append(child["oid"])
``

returse to get the children of the children.

``
            self._get_childs(child["oid"], out)
``

patient gets patients and returns them as a list of Patient instances.

the parameters work analog to the sample method.

``/patient: #py
    def patient(self, patientids=None, sampleids=None, idc=None, trials=None, orgas=None, verbose=[], verbose_all=False, like=[], order_by=None, top=None, print_query:bool=False, raw:bool=False):
        ``.``
``

vaa (verbose-all-array) holds all possible verbose options for patient.

`` #py
        vaa = [orga]
``

append the idcs for patient to the vaa array.  don't append idcs for sample, cause then one patient with fifteen samples would come out as fifteen result rows?

``
        vaa.extend(self._patientidcs())        
``


always join the patientid via verbose. put it as the first array element
for subsequent joins that might need it.

`` #py
        if not self.pidc() in verbose:
            verbose.insert(0, self.pidc())
``

replace traction constants patientid and sampleid with their idc.

``
        verbose = self._concrete_idcs(verbose)
``

on verbose_all include all constants in the verbose array.

`` #py
        if verbose_all == True:
            verbose = vaa
``

make an array of silent joins for fields that might get queried after
but shouldn't be included in the output.

`` #py
        silent = []
        if trials:
            silent.append(trial)
        if orgas:
            silent.append(orga)
``


make sure that the verbose array only contains keys from the
verbose-all-array.

// what about?
add the sampleid extra cause it strictly isn't allowed as a verbose
flag, but if verbose is used to orchestrate all joins it needs to be
in verbose for idc?

``
        if not _checkverbose(verbose, vaa):
            return None # throw error?
``

put the sampleids and patientids into idc, to handle them as just
another idcontainer for joining and in where.

``
        # todo check that self.sidc() is not in idc
        if idc is None:
           idc = {}
        if sampleids is not None:
           idc[self.sidc()] = sampleids
        if patientids is not None:
           idc[self.pidc()] = patientids
           
``

the select statements for optional joins by key.

`` #py
        selects = {
            self.pidc(): [f"idc_{self.pidc()}.psn as '{patientid}'"],
            orga: [f"organisationunit.code as '{orga}'"],
            trial: [f"flexistudy.code as '{trial}'"],
        }
``

the join statements for optional joins by key. if the same join is
needed for two different keys they are filtered out later.

pull the values from the join dict, jd.

`` #py
        joins = {
            orga: self.jd["patient_to_orga"],
            trial: self.jd["patient_to_trial"]
        }
``

for any sample idc, join in sample, which is needed by
_append_idc_joins.

``
        for sidc in self._sampleidcs():
            joins[sidc] = self.jd["patient_to_sample"]
``

put together the select string for the query. always select
patientcontainer.

`` #py
        selectstr = self._selectstr(selects, verbose, ["patientcontainer.*"], idc)  
``

put together the join string for the query. join in verbose and
silent.

``
        joinstr = self._joinstr(joins, verbose + silent, idc)  
``

get the where string.

`` #py
        (wherestr, whereargs) = self._where(trials=trials, idc=idc, verbose=verbose, like=like)
        #print(whereargs)
``

get the top string.

``
        topstr = self._top(top)
``

stick together the query. select distinct so that sample joins for
idcontainers etc don't result in a patient getting returned multiple
times if there's multiple samples.


`` #py
        query = f"select distinct {topstr} {selectstr} from centraxx_patientcontainer patientcontainer \n{joinstr} \nwhere {wherestr}"
        if order_by is not None:
            query += f" order by {order_by}"
        if print_query:
           print(query)
``

get the result.

``
        res = self.db.qfad(query, whereargs)
``

if raw is wished, return raw.

``
        if raw:
            return raw
``

make patients from the result.

``
        pats = []
        for r in res:
            ``.``
``

collect the ids.

``
            ids = [ Identifier(id=dig(r, patientid), code=self.pidc()) ]
            for idc in self._patientidcs():
                if idc in r and r[idc] is not None:
                    ids.append( Identifier(id=dig(r, idc), code=idc.upper()) )
``

build the patient.

``
            pat = Patient(
              ids=ids,
              orga=dig(r, orga),
              pidc=self.pidc()
            )
            pats.append(pat)
``

return.

``/patient
        return pats
``


the joindict entries that patient needs.

``/init/jd patient_to:
            "patient_to_orga": ["left join centraxx_patientorgunit patientorgunit on patientcontainer.oid=patientorgunit.patientcontainer_oid", "left join centraxx_organisationunit organisationunit on patientorgunit.orgunit_oid=organisationunit.oid"],
            "patient_to_trial": ["left join centraxx_patientstudy as patientstudy on patientstudy.patientcontainer = patientcontainer.oid", "left join centraxx_flexistudy as flexistudy on flexistudy.oid = patientstudy.flexistudy"],
            "patient_to_sample": ["left join centraxx_sample sample on sample.patientcontainer = patientcontainer.oid"]
``


trial gives trials.

``/trial: #py
    def trial(self):
        ``.``
``

return the trial codes for now.

``
        query = "select code from centraxx_flexistudy"
        res = self.db.qfad(query)
        return res
``

finding gets the laborfindings ("messbefund" / "begleitschein") for
sampleids or method.  it returns a list of Finding instances.

you can pass these to verbose: tr.patientid  // maybe also tr.values?

``/finding: #py
    def finding(self, sampleids=None, patientids=None, idc=None, methods=None, trials=None, values:bool=True, verbose=[], verbose_all:bool=False, print_query:bool=False, raw:bool=False):
        ``findings``
        ``values``
        ``ret``
``

for now always include the sampleid.

``/finding/findings: #py
        if self.sidc() not in verbose:
            verbose.append(self.sidc())
``

replace traction constants patientid and sampleid with their idc.

``
        verbose = self._concrete_idcs(verbose)
``

build the query for findings.  later add recorded values to each finding.

put the sampleids and patientids into idc, to handle them as just another idcontainer
for joining and in where.

``
        if idc is None:
           idc = {}
        # todo check that self.sidc() is not in idc
        if sampleids is not None:
           idc[self.sidc()] = sampleids
        if patientids is not None:
           idc[self.pidc()] = patientids
``

get the idc part of the select string.

``
        selects = {
            self.sidc(): [f"idc_{self.sidc()}.psn as '{sampleid}'"],
            self.pidc(): [f"idc_{self.pidc()}.psn as '{patientid}'"],                   
        }
        idcselectstr = self._selectstr(selects, verbose, [], idc)  
``

for any patient idc, join in patientcontainer, which is needed by
_append_idc_joins.

``
        joins = {}
        for pidc in self._patientidcs():
            joins[pidc] = self.jd["sample_to_patient"]
``

get the join string for idcs.

``
        idcjoinstr = self._joinstr(joins, verbose, idc)
``

stick together the query.

``
        query = f"""select laborfinding.oid as "laborfinding_oid", laborfinding.*, labormethod.code as {method}, {idcselectstr}
        from centraxx_laborfinding as laborfinding

        -- go from laborfinding to sample
        left join centraxx_labormethod as labormethod on laborfinding.labormethod = labormethod.oid
        left join centraxx_labormapping as labormapping on labormapping.laborfinding = laborfinding.oid
        left join centraxx_sample sample on labormapping.relatedoid = sample.oid
        {idcjoinstr}"""
``

get the where string and append it to the query.

``
        (wherestr, whereargs) = self._where(idc=idc, methods=methods, trials=trials)

        query += " where " + wherestr
        if print_query:
            print(query)
            print(whereargs)
``

get the result.

``
        results = self.db.qfad(query, whereargs)
``

for each of the findings, pull in the recorded values.

maybe only on --verbose = ["values"]

``/finding/values:
        for i, finding in enumerate(results):
            if values != True: # todo put this outside of the loop?
                continue
            ``query``
            ``put``
``

construct the query for the recorded values.

todo prefetch units?

``/finding/values/query:
            query = f"""select recordedvalue.*, laborvalue.code as laborvalue_code, laborvalue.dtype as laborvalue_type, laborvalue.custom_catalog as laborvalue_catalog_oid, unit.code as laborvalue_unit
                from centraxx_laborfinding as laborfinding

                -- go from laborfinding to recorded value
                join centraxx_labfindinglabval as labfindinglabval on labfindinglabval.laborfinding = laborfinding.oid
                join centraxx_recordedvalue as recordedvalue on labfindinglabval.oid = recordedvalue.oid

                --go from labfindinglabval to the laborvalue for the messparam
                join centraxx_laborvalue laborvalue on labfindinglabval.laborvalue = laborvalue.oid

                --go from laborvalue to unit
                left join centraxx_unity unit on laborvalue.unit = unit.oid

                where laborfinding.oid = ?
            """
``

turn the result into recorded value objects. key the values by
laborvalue_code (the messparam code).

``
            recvals = self.db.qfad(query, finding['laborfinding_oid'])
            valsbycode = {}
            for recval in recvals:
              valsbycode[recval["laborvalue_code"]] = self._make_rec(recval, finding)
``

put the values to the finding.

``/finding/values/put:
            results[i]["values"] = valsbycode
``

if raw, return.

``/finding/ret:
        if raw:
            return results
``

make findings from the results.

``
        findings = []
        for res in results:
            finding = Finding(
                findingdate=dig(res, "findingdate"),
                method=res["method"],
                methodname=res["shortname"],
                patient=Idable(id=dig(res, patientid), code=self.pidc(), mainidc=self.pidc()) if dig(res, patientid) is not None else None, 
                recs=res["values"] if "values" in res else None, # todo None ok?
                sample=Idable(id=res[sampleid], code=self.sidc(), mainidc=self.sidc()),
                sender=None
            )
            findings.append(finding)
``                     

return the findings with their respective values.

``/finding/ret
        return findings
``

_make_rec makes a recorded value instance from db results.

``/_make_rec:
    def _make_rec(self, recval, finding) -> Rec:
        ``.``
``

make different rec val instances depending on the type. see the Rec
type attribute for an overview of the different types.

convert the boolean values from integer to boolean.

``
        out:Rec = None
        if recval["laborvalue_type"] == "BOOLEAN":
            val = True if recval["boolvalue"] == 1 else False
            out = BooleanRec(method=finding["method"], labval=recval["laborvalue_code"], value=val)
``

take DECIMAL values from the numericvalue field.

somehow the cast to float seems necessary, if the Decimal from the db
result is passed, the value ends up being None.

if a number value isn't set, the db returns None (and not 0.0 or so).

``
        elif recval["laborvalue_type"] == "DECIMAL":
            #print(recval["laborvalue_code"])
            #print(recval)
            value = float(recval["numericvalue"]) if recval["numericvalue"] is not None else None
            out = NumberRec(method=finding["method"], labval=recval["laborvalue_code"], value=value, unit=recval["laborvalue_unit"])
``

there are only four laborvalues for INTEGER, and they don't seem to be
findable with erweiterte suche. TODO what to do?

handle both STRING and LONGSTRING as StringRec.

``
        elif recval["laborvalue_type"] == "STRING" or recval["laborvalue_type"] == "LONGSTRING":
            out = StringRec(method=finding["method"], labval=recval["laborvalue_code"], value=recval["stringvalue"])
``

take DATE values from datevalue and LONGDATE values from
datevalueprecision, respectively.

``
        elif recval["laborvalue_type"] == "DATE":
            out = DateRec(method=finding["method"], labval=recval["laborvalue_code"], value=recval["datevalue"])
        elif recval["laborvalue_type"] == "LONGDATE":
            out = DateRec(method=finding["method"], labval=recval["laborvalue_code"], value=recval["datevalueprecision"])
``

for catalog, query the actual catalog entries. go from recordedvalue
to catalogentry via the recordedval_catentry table.

``
        elif recval["laborvalue_type"] == "CATALOG":
            # get the catalog code
            query = f"""select catalog.code as 'catalog_code' from centraxx_catalog as catalog
            where catalog.oid = ?""" # do this once for all catalogs on startup or finding() call?
            res = self.db.qfad(query, recval['laborvalue_catalog_oid'])
            catalog_code = res[0]["catalog_code"]
            # get the catalog entries
            query = f"""select catalogentry.code as 'catalogentry_code' from centraxx_recordedvalue as recordedvalue
            join centraxx_recordedval_catentry as recordedval_catentry on recordedval_catentry.recordedvalue_oid = recordedvalue.oid
            join centraxx_catalogentry as catalogentry on catalogentry.oid = recordedval_catentry.catalogentry_oid
            where recordedvalue.oid = ?"""
            res = self.db.qfad(query, recval['oid'])
            entries = []
            for r in res:
                entries.append(r["catalogentry_code"])
            
            out = CatalogRec(method=finding["method"], labval=recval["laborvalue_code"], catalog=catalog_code, values=entries)
``

for enumeration and option group, query the actual usage entries. go from recordedvalue
to usageentry via the recordedval_usageentry table.

for now, use a MultiRec type, that is the same as CatalogRec type,
except without catalog code?

``
        elif recval["laborvalue_type"] == "ENUMERATION" or recval["laborvalue_type"] == "OPTIONGROUP":
            query = f"""select usageentry.code as 'usageentry_code' from centraxx_recordedvalue as recordedvalue
            join centraxx_recordedval_usagentry as recordedval_usagentry on recordedval_usagentry.recordedvalue_oid = recordedvalue.oid
            join centraxx_usageentry as usageentry on usageentry.oid = recordedval_usagentry.usageentry_oid
            where recordedvalue.oid = ?"""
            res = self.db.qfad(query, recval['oid'])
            entries = []
            for r in res:
                entries.append(r["usageentry_code"])
            
            out = MultiRec(method=finding["method"], labval=recval["laborvalue_code"], values=entries)
``

else throw an exception.

``
        else:
            raise Exception(f"no record class for laborvalue of type {recval['laborvalue_type']}")
``

return.

``
        return out
``

method (messprofil) gets method(s) and their labvals (messparameter).
        
``/method:
    def method(self, methods=None):
        ``.``
``

the query.

``
        query = f"""select laborvalue.*, labormethod.code as "method"
from centraxx_labormethod labormethod
inner join centraxx_crftemplate crf_t
    on labormethod.crf_template=crf_t.oid
inner join centraxx_crftempsection crf_ts
    on crf_t.oid=crf_ts.crftemplate
inner join centraxx_crftempsection_fields crf_tsf
    on crf_ts.oid=crf_tsf.crftempsection_oid
inner join centraxx_crftempfield crf_tf
    on crf_tsf.crftempfield_oid=crf_tf.oid
inner join centraxx_laborvalue laborvalue
    on crf_tf.laborvalue=laborvalue.oid"""
``

add the where string.

``
        (wherestr, whereargs) = self._where(methods=methods)

        if wherestr:
          query += " where " + wherestr
        # print(query)
``

return the result.

``
        res = self.db.qfad(query, whereargs)
``

key by method code.

``
        out = {}
        for row in res:
          mc = row[method]
          if mc not in out:
            out[mc] = {}
          del row[method]
          out[mc] = row
        
        return out
``

name gives the multilingual names for a code or all codes in a table.

the result is keyed by code and language like this:


"NUM_NMR_ISOLEUCINE_VALUE": {  
   "de": "Isoleucin",  
   "en": "Isoleucine"  
}


table: the name of the centraxx table without centraxx_ prefix  
code: a specific code, if none given, all code - name mappings for table are given  
lang: de|en  
ml_table: if the name of the table connecting to multilingualentry is not simlpy the queried table name followed by "_ml_name", give the connecting table's name here. eg: name('laborvaluegroup', ..., ml_name='labval_grp_ml_name')  


``/name:
    def name(self, table:str, code:str=None, lang:str=None, ml_table:str=None):
        ``.``
``

interlacing the table name assumes that the referencing pattern for multilingual entries stays the same across table names.

``
        query = "select [" + table + "].code, multilingual.value as name, multilingual.lang as lang"
        query += " from [centraxx_" + table + "] as [" + table + "]"
``

put together the name for the ml_table.

``
        ml_name = ""
        if ml_table != None: # the name is different
            ml_name = "centraxx_" + ml_table
        else: # the name is the same
            ml_name = "centraxx_" + table + "_ml_name"
``

add it to the query.

``
        query += " inner join [" + ml_name + "] mlname on mlname.related_oid = [" + table + "].oid"
        query += " inner join centraxx_multilingualentry multilingual on mlname.oid = multilingual.oid"
``

restrict the query to specific lang or code if given.

``
        wherestrings = []
        args = []
        if code != None:
            wherestrings.append(self._whereparam("[" + table + "].code"))
            args.append(code)
        if lang != None:
            wherestrings.append(self._whereparam("multilingual.lang"))
            args.append(lang)
``

only add sql-where if needed

``
        if len(wherestrings) > 0:
            query += " where "
            # join where clauses by and
            query += " and ".join(wherestrings)

        # print(query)
``

query.

``
        res = self.db.qfad(query, *args)
``

structure by code and lang and return.

``
        out = {}
        for line in res:
            code = line["code"]
            lang = line["lang"]
            if not code in out:
               out[code] = {}
            out[code][lang] = line["name"]
        return out
``

sidc returns the main idc code by which samples are referenced as
specified in the settings. 

``/sidc:
    def sidc(self) -> str:
        return self.settings['sampleid'][self.db.target]
``

sidc returns the main idc code by which patients are referenced as
specified in the settings. 

``/pidc:
    def pidc(self) -> str:
        return self.settings['patientid'][self.db.target]
``

_sampleidcs returns the idcs from settings that are specific for sample.

rather make this a section in conf?

# idc holds idcontainer codes that should be queryable as command line flags 
idc:
  sample:
    - extsampleid
    - modul
    - tier
  patient:
    - mpi

``/_sampleidcs:
    def _sampleidcs(self) -> list:
        ``.``
``

the settings can list idc codes that are not applicable to this target, skip them.

``
        out = []
        for idc in self.settings["idc"]:
            if idc in self._idckind and self._idckind[idc] == "SAMPLE":
                out.append(idc)
        # include the main sample idcontainer
        out.append(self.sidc())
        return out
``

patientidcs returns the idcs from settings that are specific for sample.

``/_patientidcs:
    def _patientidcs(self) -> list:
        ``.``
``

the settings can list idc codes that are not applicable to this target, skip them.

``
        out = []
        for idc in self.settings["idc"]:
            if idc in self._idckind and self._idckind[idc] == "PATIENT":
                out.append(idc)
        # include the main patient idcontainer
        out.append(self.pidc())
        return out
``

replace traction constants patientid and sampleid with their
respective idc.

``/_concrete_idcs:
    def _concrete_idcs(self, verbose):
        ``.``
``

fill in the concrete idcs when encountering patientid or sampleid.

``
        out = []
        for verb in verbose:
            if verb == patientid:
                out.append(self.pidc())
            elif verb == sampleid:
                out.append(self.sidc())
            else:
                out.append(verb)
        return out
``

_fill_in_primary adds a reference to the given sample's primary sample,
if there is one.

``/_fill_in_primary:
    def _fill_in_primary(self, sample:Sample):
        ``.``
``

get the parent oids. 

``
        poids = []
        self._get_parents(sample.id("oid"), poids)
``

the first parent is the primary, take it.

``
        if len(poids) > 0:
            primary_oid = poids[0]
            ``.``
``

query the primary to get its sampleid, reference it from the sample as
Idable.

``
            primary = self.sample(oids=[primary_oid])[0]
            sample.primary = Idable(ids=primary.ids, mainidc=primary.mainidc)
``

_selectstr filters the selects by the verbose array and returns the
sql select string. selecta is for fields that should be selected
regardless if they're in the verbose array or not.

the idc argument assumes that the sample table is joined it. // todo is this still true?

``/_selectstr: #py
    def _selectstr(self, selects, verbose, selecta, idc):
        for verb in verbose:
            ``.``        
``

skip verbose entries that are not in the selects dict, they are
probably idc selects that are handled later.

``
            if not verb in selects:
                continue
``

put in the select line(s).

``
            for s in selects[verb]:
                selecta.append(s)
``

append idc selects.

``/_selectstr #py
        selecta = self._append_idc_select(selecta, idc, verbose)
``      

get the selections and joins as string.

`` #py
        selectstr = ", \n".join(selecta)
        return selectstr
``

_joinstr puts together the joins needed by verbose array and idc keys
and returns the sql join string.

``/_joinstr: #py
    def _joinstr(self, joins, verbose, idc):
        ``.``
``

first put in the idc joins, cause other joins might need them.

``
        joina = []
        joina = self._append_idc_join(joina, idc, verbose, joins)
``

now put in joins for verbose.

could you substract idc from verbose here cause there were already taken care of?

``
        for verb in verbose: 
            ``.``
``


skip verbose entries that are not in the joins dict, //they are 
probably idc joins that are handled later. ?true?

``
            if not verb in joins:
                continue
``

put in the join line(s). make sure that join clauses aren't included
double, for example both locationpath and locationname join in
samplelocation, so check that it's not already in the join array.

``
            for s in joins[verb]:
                if not s in joina:
                    joina.append(s)
``


get the joins as string.

`` #py
        joinstr = " \n".join(joina)
        return joinstr
``

_append_idc_select adds the sql select statements for an idc dict.

``/_append_idc_select:
    def _append_idc_select(self, selecta, idc, verbose):
        ``.``
``

put in the members of verbose touched by idc.

``
  idca = []
  for verb in verbose:
    if verb in self.settings["idc"]:
      idca.append(verb)
``    

make select strings and append them.

``
  for item in idca:
    selectstr = f"idc_{item}.psn as '{item}'"
    if not selectstr in selecta:
      selecta.append(selectstr)
``

return the selecta with appended strings.

``
  return selecta
``

_append_idc_join adds the sql join statements for an idc dict.

``/_append_idc_join: #py
    def _append_idc_join(self, joina, idc, verbose, joins):
        ``.``
``

put in the members of verbose touched by idc and the keys of idc into
a common array.

``
        idca = []
        for verb in verbose:
          if verb in self.settings["idc"] or verb == self.sidc() or verb == self.pidc():
            idca.append(verb)
        if idc is not None:
          idca.extend(idc.keys())
``

add a join for each member of the idc array.

the joins are different for idckind SAMPLE and PATIENT.

``
        for item in idca:
          ``intermediary``
          if self._idckind[item] == "SAMPLE":
            ``sample``
          elif self._idckind[item] == "PATIENT":
            ``patient``
          else:
            print(f"error: idcontainer kind {self._idckind[item]} not supported.")
``

put in idc-intermediary joins, for when sample joins in patient idcs and
needs patientcontainer for that or vice versa. 

``./intermediary:
          if item in joins:
            for s in joins[item]:
              if s not in joina:
                joina.append(s)
``


join in sampleidcontainer for SAMPLE. prefix it with idc_ instead of
sidc_, so that there can be one where-check that uses the idc_ prefix
for both patient and sample idcontainers.

when joining in idcontainers, we need to check their respective
idcontainer type. do this here as opposed to the where clause at the
end of the query, cause here if a idcontainer is not set checking here
just makes the field null in the result row, whereas checking in the
where clause it excludes the entire row.

``../sample:
        joinstr = f"left join centraxx_sampleidcontainer as idc_{item} on idc_{item}.sample = sample.oid and idc_{item}.idcontainertype = {self._idcoid[item]}"

        if not joinstr in joina:
          joina.append(joinstr)
``

join in idcontainer via patientcontainer for PATIENT:

``../patient:
        joinstr = f"left join centraxx_idcontainer as idc_{item} on idc_{item}.patientcontainer = patientcontainer.oid and idc_{item}.idcontainertype = {self._idcoid[item]}"
        if not joinstr in joina: # neccessary?
          joina.append(joinstr)
``

return the selecta with appended strings.

``/_append_idc_join
        return joina
``

_where returns the wherestring and args array for the provided
arguments (that are not None).

the user needs to make sure that whatever is referenced here is joined
into the query before.

the names are assumed to be the tr constants, like
e.g. tr.sampleid. like is an array of tr constants of the arguments
for which it checks likeness. we only check likeness for the first
passed string of an argument array. if for example
like=[tr.locationpath], it checks likeness of locationpaths[0].

make sure only one of sampleids or extsampleids is passed?

``/_where:
    def _where(self, idc={}, sampleoids:list=None, parentids=None, parentoids=None, patientids=None, trials=None, locationpaths=None, kitids=None, cxxkitids=None, categories=None, samplingdates=None, receiptdates=None, derivaldates=None, first_repositiondates=None, repositiondates=None, stockprocessingdates=None, secondprocessingdates=None, methods=None, like=[], verbose=[], wherearg:str=None): # -> (str, [])
        ``.``
``

put the where-info for each field that could appear in the verbose
array into wheredict along with the passed arguments.

arr: the array of values to check against
field: the table and field where it should match. 

``
        wheredict = { 
          trial: { "arr": trials, "field": "flexistudy.code" },
          locationpath: { "arr": locationpaths, "field": "samplelocation.locationpath" },
          method: { "arr": methods, "field": "labormethod.code" },
          kitid: { "arr": kitids, "field": "samplekit.kitid" },
          cxxkitid: { "arr": cxxkitids, "field": "samplekit.cxxkitid" },
          category: { "arr": categories, "field": "sample.dtype" },
          parentid: { "arr": parentids, "field": "parentidc.psn" },
          parentoid: { "arr": parentoids, "field": "sample.parent" },
          sampleoid: { "arr": sampleoids, "field": "sample.oid" },          
          samplingdate: { "arr": samplingdates, "field": "sample.samplingdate", "type": "date" },
          receiptdate: { "arr": receiptdates, "field": "sample.receiptdate", "type": "date" },
          derivaldate: { "arr": derivaldates, "field": "sample.derivaldate", "type": "date" },
          first_repositiondate: { "arr": first_repositiondates, "field": "sample.first_repositiondate", "type": "date" },
          repositiondate: { "arr": repositiondates, "field": "sample.repositiondate", "type": "date" },
          stockprocessingdate: { "arr": stockprocessingdates, "field": "sample.stockprocessingdate", "type": "date" },
          secondprocessingdate: { "arr": secondprocessingdates, "field": "sample.secondprocessingdate", "type": "date" }
        }
``

add the passed idcs to the wheredict.

there could be items in verbose that are queried via the idc (for
example?), get them with the intersection call.

``
        idckeys = [] if idc is None else idc.keys()
        idca = list(idckeys) + list(set(verbose).intersection(self.settings["idc"]))
        for item in idca:
            wheredict[item] = {
                                "arr": idc[item] if idc is not None and item in idc else None,
                                "field": f"idc_{item}.psn"
                             }
``

stick together where clauses and arguments that covers the args that
are not None and the constants in verbose. return the wherestring and
args array.

``
        (wherearr, whereargs) = self._wherebuild(wheredict, like, verbose)

        wherestr = " and ".join(wherearr)
``

add the where string passed as argument.

``
        if wherearg is not None:
           wherestr += " and (" + wherearg + ")"
``

return.

``
        return (wherestr, whereargs)
``

_wherebuild builds wherestrings and fills whereargs.

``/_wherebuild:
    def _wherebuild(self, wheredict, likearr=[], verbose=[]): # ([]string, [])
        ``.``
``

add where clauses to wherestrs and their respective arguments to
whereargs.

``
        wherestrs = []
        whereargs = []
``

iterate the passed wheredict. it contains all possible joins. build
where clauses for joins where the "arr" field is set.

key is one of the tr constant strings, e.g. tr.locationpath.

``
        for (key, row) in wheredict.items():
            if row["arr"] == None or len(row["arr"]) == 0:
                continue

            if likearr is not None and key in likearr:
                ``like``
            elif row["arr"] is not None and "type" in row and row["type"] == "date":
                ``date``
            else:
                ``exact``
``

we only look at wheredict entries where there is something in the
"arr" field.

if should we check for likeness for this key, put in a like clause.

``/_wherebuild/like:
                # put in an or-chain of like checks over all elements
                s = "(" + self._wherelikes(row["field"], len(row["arr"])) + ")"
                wherestrs.append(s)
                whereargs.extend(row["arr"])
``

if it's a date check, check that it's between the two values of the
array passed as date parameter.

CAST removes the time component, this is needed for getting samples
from one day (when both dates are the same).

ISNULL handles missing start or end date. is this smart, or rather
check for >=, <= etc if only one date is given?

for null checks, instead of the date tuple, 'NULL' is passed. maybe a
bit hacky?

``/_wherebuild/date:
               if row["arr"] == 'NULL':
                   wherestrs.append("(" + row['field'] + " is NULL)")
               else:
                   s = f"(CAST(" + row['field'] + " as date) between ISNULL(?, " + row['field'] + ") and ISNULL(?, " + row['field'] + "))"
                   wherestrs.append(s)
                   whereargs.extend(row["arr"])
``

else put in an exact-match clause.

open the where string.

``/_wherebuild/exact:
                wherestr = "("
``

make null checks extra, e.g. '(kitid is NULL or kitid in (1, 2, 3))'.

if is there a 'NULL' in the array, put in a NULL check and remove it
from the array, so it doesn't mess with the where-arguments later.

``
                needsor = False
                if 'NULL' in row["arr"]:
                    row["arr"].remove("NULL")
                    wherestr += row["field"] + " is NULL"
                    needsor = True
``

if there is anything left in the array, make the in-list part of the
wherestring with the ?-placeholder string.

``
                if len(row["arr"]) > 0:
                    if needsor:
                        wherestr += " or "
                    placeholder = traction._sqlinplaceholder(len(row["arr"])) # todo put in package? tr._sqlinplaceholder
                    wherestr += row["field"] + " in " + placeholder # e.g. samplelocation.locationpath in (?, ?, ?)
``

close the exact-match wherestr with ) and put the wherestring and its arguments
into their corresponding arrays.

``
                wherestr += ")"
                wherestrs.append(wherestr)
                whereargs.extend(row["arr"])
``


after the loop return.

``/_wherebuild/
        return (wherestrs, whereargs)
``

    
_sqlinplaceholder returns a string like (?, ?, ?, ? ...) with n question marks for sql in.

``/_sqlinplaceholder:
    def _sqlinplaceholder(n):

        # put this in a package sqlutil?

        out = "("
        for i in range(n):
            out += "?"
            if i < n - 1:
                out += ","
        out += ")"
        return out
``

_whereparam gives a ?-parameterized sql where expression for name
equal or like parameter for use in queries.

``/_whereparam:
    def _whereparam(self, name, like:bool=None):
        if like == None or like == False:
            return name + " = ?"
        else:
            return name + " like '%' + ? + '%'"
``

_wherelike gives a ?-parameterized sql where like expression.

``/_wherelike:
    def _wherelike(self, name):
        return name + " like '%' + ? + '%'"

``

_wherelikes gives a ?-parameterized sql of or-joined where-like
expressions, as many as given n.

``/_wherelikes:
    def _wherelikes(self, field, n):
        a = []
        for i in range(n):
            a.append(field + " like '%' + ? + '%'") # the sql takes literal plusses like here
        return " or ".join(a)
``

_top returns the top string, for, e.g. `select top 100 * from table`, if
top is None return an empty string.

``/_top:
    def _top(self, top):
        if top is not None:
           return f"top {top}"
        return ""
``                             

_idcinit makes a mapping of idcontainers from their code (lower-case) to respective oid and kind.

``/_idcinit:
    def _idcinit(self):
        ``.``
``

get the codes and oids.

``
        query = "select code, oid, kind from centraxx_idcontainertype"
        res = self.db.qfad(query)
``

return idcontainer oids and kinds keyed by their code.

``
        self._idcoid = {}
        self._idckind = {}
        for row in res:
          self._idcoid[row["code"]] = row["oid"]
          self._idckind[row["code"]] = row["kind"]
``

_checkverbose makes shure that only allowed keys are in the verbose array. 

``/_checkverbose:
def _checkverbose(verbose, possible):
    for verb in verbose:
        if not verb in possible: 
            print(f"error: verbose entry {verb} must be in {possible}.")
            return False
    return True
``

floatornull casts to float or returns None. somehow the values passed
to Amount need float casts, and float casts don't accept None.

``/floatornull:
def floatornull(x):
    if x is None:
        return None
    return float(x)
``

get_ids returns a list of string ids from a list of Idables (Sample or
Patient).

``/get_ids:
def get_ids(idables:list, code:str=None) -> list:
    return [ x.id(code) for x in idables ]
``

Idable holds a list of identifiers with idcontainer codes and
remembers which is the main idc code.

``/idable class:
class Idable:
    ``init``
    ``identifier``
    ``id``
    ``iddict``    
    ``__str__``
``

__init__ initializes an Idable from a list of Identifiers and a
mainidc string.

``/idable class/init:
    def __init__(self, ids:list=None, mainidc:str=None, id=None, code:str=None):
        self.ids = ids
        if self.ids is None:
            self.ids = []
        self.mainidc = mainidc
``

id and code give a shortcut for creating a list.

``
        if id is not None:
            self.ids.append(Identifier(id=id, code=code))
``

identifier returns the Identifier for the given code, if no code
given, the Identifier for the main idc returned.


``/idable class/identifier:
    def identifier(self, code:str=None) -> Identifier:
        ``.``
``

take the standard sampleid container if no code is passed.

``
        if code == None:
            code = self.mainidc
``

iterate the identifiers, if its code matches self.sidc, return.

``
        for identifier in self.ids:
            if identifier.code == code:
                return identifier
``


id returns the id value for the given code, if no code
given, the id value for the main idc is returned.


``/idable class/id:
    def id(self, code:str=None) -> str:
        if self.identifier(code) is not None:
            return self.identifier(code).id
        return None 
``

__str__ gives a human readable representation of Idable, here the
id string.

``/idable class/__str__:
    def __str__(self):
        if self.id() is not None:
            return self.id()
        return ""
``

iddict returns a copy of the __dict__ holding the given ids at the
root level of the dict in addition to the classes attributes.  if no
ids are given, all ids taken.  the ids and mainidc fields are cleared,
exept when keep is true. if iddict is called on an inheriting class
(e.g. Sample) the dict gives the inheriting classes attributes.

``/idable class/iddict:
    def iddict(self, *idcs):
        ``.``
``

the first asterix before idcs indicates that any number of idcs can be
passed.

make a copy of the dict holding all attributes.

``
        d = self.__dict__.copy()
``

if no specific idcontainers are given, take all.

``
        if idcs == None or len(idcs) == 0:
            idcs = [id.code for id in self.ids]
``

put the ids in the root level of the dict.

``
        for idc in idcs:
            d[idc] = self.id(idc)
``

delete the ids and mainidc field from dict.

``
        del d["ids"]
        del d["mainidc"]
``

return the dict.

``
        return d
``
        


Sample holds a sample.

``/sample class:
class Sample(Idable):
    ``var``
    ``init``
    ``default``
    ``sampleid``
    ``__getstate__``
``

declare the variables.

appointment holds sample's visit (appointmentnumber in db).

``/sample class/var:
    appointment:str = None
``


category holds the sample's category, MASTER, ALIQUOTGROUP or
DERIVED. called dtype in db.

``
    category:str = None
``

concentration holds the sample's concentration.

``
    concentration=None
``

derivaldate holds the sample's derival date (when it was derived as an
aliquot).

``
    derivaldate:datetime=None
``

receiptdate holds the date of the samples entry into the
laboratory. called receiptdate in the db.

``
    receiptdate:datetime=None
``

first_repositiondate holds the sample's first repositioning date. this
can't be changed after it was first written (by what? db?
fhir?). since it doesn't change like the repositiondate field, but
stays on the first time the sample was stored, it should hold the date
the sample was frozen.

``
    first_repositiondate:datetime=None
``


initialamount holds the sample's initial amount.

``
    initialamount:Amount=None
``

locationname holds the last part of the locationpath, the rack name.

``
    locationname:str=None
``

locationpath holds the sample's locationpath.

``
    locationpath:str=None
``

orga holds the sample's organization unit. called orgunit in the db.

``
    orga:str = None
``

parent holds this samples parent as Idable with potentially multiple
identifiers (oid, sampleid if there). oids are needed to keep track of
aliquotgroups.

``
    parent:Idable=None 
``

patient references the patient as Idable.

``
    patient:Idable = None
``

project holds?

``
    project:str = None
``

receptacle holds the sample's receptacle. called receptable in the db.

``
    receptacle:str=None
``

restamount holds the sample's rest amount. in db fields amountrest and restunit.

``
    restamount:Amount=None
``

samplingdate holds the date when the sample was extracted from the patient.

``
    samplingdate:datetime=None
``

secondprocessing holds the code of the second centrifugation.

``
    secondprocessing:str=None
``

secondprocessingdate holds the date of the second centrifugation.

``
    secondprocessingdate:datetime=None
``

stockprocessing holds the code of the first centrifugation.

``
    stockprocessing:str=None
``

secondprocessing holds the date of the first centrifugation.

``
    stockprocessingdate:datetime=None
``

repositiondate holds the date of the sample's latest repositioning (umlagern). 

``
    repositiondate:datetime=None
``

trial holds the trial code.

``
    trial:str=None
``

type holds the code of the sample's type/material (whole blood, EDTA,
liquor, etc). called sampletype in db.

``
    type:str=None
``

xposition holds the sample's x position on the rack.

``
    xposition:int=None
``

yposition holds the samples y position in the db.

``
    yposition:int=None
``

__init__ initializes a sample.

``/sample class/init:
    def __init__(
         self,
         appointment:str=None,
         category:str=None,
         cxxkitid:str=None,
         concentration=None, # str?
         derivaldate:datetime=None,
         first_repositiondate:datetime=None,
         ids:list=None, # of Identifier         
         initialamount:Amount=None,
         kitid:str=None,
         locationpath:str=None,
         locationname:str=None,
         orga:str=None,
         parent:Idable=None,
         patient:Idable=None,
         project:str=None,
         receptacle:str=None, 
         restamount:Amount=None,
         samplingdate:datetime=None,
         secondprocessing:str=None,
         secondprocessingdate:datetime=None,         
         stockprocessing:str=None,
         stockprocessingdate:datetime=None,         
         receiptdate:datetime=None,         
         repositiondate:datetime=None,
         sidc:str=None,
         trial:str=None,
         type:str=None,
         xposition:int=None, 
         yposition:int=None
         ):
        ``.``
``

call super.

``
        Idable.__init__(self, ids, sidc)
``

fill in the parameters.

``
        self.appointment = appointment
        self.category = category
        self.cxxkitid = cxxkitid
        self.concentration = concentration
        self.derivaldate = derivaldate
        self.receiptdate = receiptdate
        self.first_repositiondate = first_repositiondate
        self.initialamount = initialamount
        self.kitid = kitid
        self.locationpath = locationpath
        self.locationname = locationname
        self.orga = orga
        self.parent = parent
        self.patient = patient
        self.project = project
        self.receptacle = receptacle
        self.repositiondate = repositiondate
        self.restamount = restamount
        self.secondprocessing = secondprocessing
        self.secondprocessingdate = secondprocessingdate        
        self.stockprocessing = stockprocessing
        self.stockprocessingdate = stockprocessingdate        
        self.samplingdate = samplingdate        
        self.trial = trial
        self.type = type
        self.xposition = xposition
        self.yposition = yposition
``

default returns the json dict.

``/sample class/default:
    def default(self, o):
        return o.__dict__
``

sampleid is a shorthand to get the sampleid so it isn't buried in a
dict when displaying the object as json.

``/sample class/sampleid:
    @property
    def sampleid(self):
        return "bla" # self.get_id()
``

__getstate__ returns what gets jsonpickled. include sampleid and
patientid in root level, for quicker access.

``/sample class/__getstate__:
    def __getstate__(self):
        state = self.__dict__.copy() # is this slow?
        state[sampleid] = self.id()
        state[patientid] = self.patient.id() if self.patient else None
        return state
``

import.

``/import
#from json import JSONEncoder
import jsonpickle
``

Identifier holds an identifier.

``/identifier class:
class Identifier:
    ``init``
``

__init__ initializes an identifier.

``/identifier class/init:
    def __init__(self, id=None, code:str=None):
        ``.``
``

remember the arguments.

``
        self.id = id
        self.code = code
``


Amount holds an amount.

``/amount class:
class Amount:
    ``init``
    ``__str__``
``

__init__ initializes an amount.

``/amount class/init:
    def __init__(self, value:float=None, unit:str=None):
        ``.``
``

remember the arguments.

``
        self.value = value
        self.unit = unit
``

__str__ gives the value and unit in human-readable format.

``/amount class/__str__:
    def __str__(self):
        return str(self.value) + " " + self.unit
``

Patient holds a patient.

``/patient class:
class Patient(Idable):
    ``init``
    ``__getstate__``
``

__init__ initializes a patient.

``/patient class/init:
    def __init__(
      self,
      ids:list=None,
      orga:str=None,
      pidc:str=None
    ):
        ``.``
``

call super.

``
        Idable.__init__(self, ids, pidc)
``


remember the paramenters.

``
        self.orga = orga
``

__getstate__ returns what gets jsonpickled. include the patientid at the root level, for quicker access.

``/patient class/__getstate__:
    def __getstate__(self):
        state = self.__dict__.copy() # is this slow?
        state[patientid] = self.id()
        return state
``


``/finding class:
class Finding:
    ``var``
    ``init``
``

method holds the finding's method (messprofil).

``/finding class/var:
    method:str=None
``

findingdate holds the finding's finding date.

``
    findingdate:datetime=None
``

methodname holds the finding's method name. (why extra?).

``
    methodname:str=None
``

patient references the patient this finding belongs to.

``
    patient:Idable=None
``

recs holds a list of recorded values for this finding.

``
    recs:map={} # of Rec, by code
``

sample references the sample Idable this finding belongs to.

``
    sample:Idable
``

sender holds the sender.

``
    sender:str=None
``

__init__ initializes a finding.

``/finding class/init:
    def __init__(self,
        findingdate:datetime=None,
        method:str=None,
        methodname:str=None,
        patient:Idable=None,        
        recs:map={}, # of Rec, by code
        sample:Idable=None,
        sender:str=None,
    ):
        ``.``
``

remember the arguments.

``
        self.findingdate = findingdate
        self.method = method
        self.methodname = methodname
        self.patient = patient
        self.recs = recs
        self.sample = sample
        self.sender = sender
``
    

Rec is the base class for recorded values like StringRec, etc.

``/rec:
class Rec:
    ``var``
    ``init``
``

hold method (messprofil) and labval (messparameter) codes?

``/rec/var:
    method:str = None
    labval:str = None
``

type holds the laborvalue's type (dtype in the db). it can be:

STRING (e.g. RNA_CONCENTRATION_NG_L)
LONGSTRING (e.g. FILES)
CATALOG (e.g. PATHOGEN2. references the catalog used via the custom_catalog field. choicetype SELECTONE or SELECTMANY)
ENUMERATION (e.g. REASONNOSAMPLES2. from kontrolliertes vokabular, the labvalenum_usageentry field specifies which kontrolliertes vokabular can be used. choicetype SELECTONE or SELECTMANY)
BOOLEAN (e.g. IS_REST)
OPTIONGROUP (e.g. NSN_INF_MODUL. checkboxes, from kontrolliertes vokabular, also via labvalenum? choicetype SELECTONE or SELECTMANY)
DATE (e.g. TIMEPOOL)
LONGDATE (e.g. PLANNEDSAMPLINGDATE_1. what's the difference between DATE and LONGDATE?)
DECIMAL (e.g. NUM_BAL_SPUELVOLUMEN. is this float?)
INTEGER (e.g. URNCT)

``
    type:str = None
``

__init__ inits a Rec.

``/rec/init:
    def __init__(self, method:str=None, labval:str=None):
        self.labval = labval
``


BooleanRec holds a BOOLEAN rec.

``/booleanrec:
class BooleanRec(Rec):
    ``var``
    ``init``
``

value is the boolean value for the rec.

``/booleanrec/var:
    value:bool = None
``

__init__ inits a BooleanRec.

``/booleanrec/init:
    def __init__(self, method:str=None, labval:str=None, value:bool=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``

NumberRec holds a DECIMAL rec. (what about INTEGER?)

``/numberrec:
class NumberRec(Rec):
    ``var``
    ``init``
``

value is the number value for the rec.

is float ok for all?

``/numberrec/var:
    value:float = None
``

unit is the unit via the laborvalue.

``
    unit:str = None
``

__init__ inits a NumberRec.

``/numberrec/init:
    def __init__(self, method:str=None, labval:str=None, value:float=None, unit:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
        self.unit = unit
``


StringRec holds a STRING or LONGSTRING rec.

``/stringrec:
class StringRec(Rec):
    ``var``
    ``init``
``

value is the string value for the rec.

``/stringrec/var:
    value:str = None
``

__init__ inits a StringRec.

``/stringrec/init:
    def __init__(self, method:str=None, labval:str=None, value:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``

DateRec holds a DATE or LONGDATE rec.

``/daterec:
class DateRec(Rec):
    ``var``
    ``init``
``

value is the date value for the rec.

``/daterec/var:
    value:datetime = None
``

__init__ inits a DateRec.

``/daterec/init:
    def __init__(self, method:str=None, labval:str=None, value:datetime=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``


MultiRec holds an OPTIONGROUP or ENUMERATION rec.

``/multirec:
class MultiRec(Rec):
    ``var``
    ``init``
``

values holds the usage entry (kontrolliertes vokabular) codes.

``/multirec/var:
    values:str = None
``

__init__ inits a MultiRec.

``/multirec/init:
    def __init__(self, method:str=None, labval:str=None, values:list=None):
        Rec.__init__(self, method=method, labval=labval)
        self.values = values
``


CatalogRec holds a CATALOG rec.

``/catalogrec:
class CatalogRec(Rec):
    ``var``
    ``init``
``

values holds the catalog entry codes.

``/catalogrec/var:
    values:str = None
``

catalog holds the catalog code.

``
    catalog:str = None
``

__init__ inits a CatalogRec.

``/catalogrec/init:
    def __init__(self, method:str=None, labval:str=None, values:list=None, catalog:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.values = values
        self.catalog = catalog
``

idable_csv writes a list of Idables to the given csv file. the given
idcontainers are included as columns. if no idcontainers are given, all
are included.

``/idable_csv:
def idable_csv(idables:list, filename:str=None, *idcs) -> str:
    ``.``
``

if no idables return. 

``
    if idables is None or len(idables) == 0: # todo throw error?
        print("no idables")
        return None
``

open the file.

``
    with open(filename, "w") as f:
        ``write``
``

make a csv writer.

``./write:
        writer = csv.writer(f)
``

take as colum names the keys of the iddict from the first idable.

``
        writer.writerow(list(idables[0].iddict(*idcs).keys()))
``

write the list of dict items for each idable.

``
        for idable in idables:
            d = idable.iddict()
            writer.writerow(list(d.values()))
``

return the name of the file.

``
    return filename
``

import csv.

``/import
import csv
``