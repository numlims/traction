# traction

commonly used getters (and setters?) for centrax db.

``//__init__.py: #py
``import``
``const``
``_checkverbose``
``_readsettings``
``_hassettings``
``_settingspath``
class traction:
  #`vars``
  ``jd``
  ``init``

  ``sample``
  ``patient``
  ``trial``
  ``finding``
  ``labval``
  ``name``

  ``_selectstr``
  ``_joinstr``
  ``_append_idc_select``
  ``_append_idc_join``
  ``_where``
  ``_wherebuild``
  ``_sqlinplaceholder``
  ``_whereparam``
  ``_wherelike``
  ``_wherelikes``
  ``_top``
  ``_idcinit``
  
``

put constants here so you can say sample(..., verbose=[tr.parentid,
tr.locationpath]).

keep them lowercase that they are the same as the keys in the returned
json?

``/const: #py
cxxkitid = "cxxkitid"
collectiondate = "samplingdate" # entnahmedatum / extraction date
derivaldate = "derivaldate" # aufteilungsdatum / date of distribution
dtype = "dtype" # MASTER, ALIQUOTGROUP, DERIVED. maybe rename this to sampletype and sampletype (EDTA, stool etc) to samplekind as in the ui?
extsampleid = "extsampleid"
first_repositiondate = "first_repositiondate" # datum der ersten einlagerung / date of first storage (not in fhir). is identical to derivaldate.
method_code = "method_code"
module = "module"
kitid = "kitid"
locationname = "locationname"
locationpath = "locationpath"
orgunit_code = "orgunit_code"
parentid = "parentid"
patientid = "patientid"
project_code = "project_code"
receiptdate = "receiptdate" # eingangsdatum / date of receipt
receptacle_code = "receptacle_code"
repositiondate = "repositiondate" # einlagerungsdatum / storage date
sampleid = "sampleid"
sampletype_code = "sampletype_code"
secondprocessing_code = "secondprocessing_code"
stockprocessing_code = "stockprocessing_code"
trial_code = "trial_code"
tier = "tier"
values = "values"
``

make a join-dict, jd.

``/jd:
    jd = {
        ``sample_to``
        ,
        ``patient_to``
    }
``

__init__ takes the db target either as string or dbcq object.

``/init: #py
    def __init__(self, target):
        ``.``
``

get the settings. 

``
        self.settings = _readsettings()
``

if no settings, do nothing. if the settings file is missing,
_readsetting creates it and asks the user to edit it.

``
        if self.settings == None:
            raise Exception("no settings.")
            return
``


either pass a string argument to dbcq or use dbcq instance directly.

`` #py
        if isinstance(target, str):
            self.db = dbcq(target)
        elif isinstance(target, dbcq): 
            self.db = target
        else:
            raise Exception("target needs to be string or dbcq instance")
``

cache the id containers' oids and kinds by code.

``
        self._idcinit()
        #print(f"_idcoids: {self._idcoids}")
``

import dbcq.

``/import: #py
from dbcq import *
``

sample gets sample(s) by sampleid or external id. pass sampleids as
array. to join in more information, say verbose_all=True, this is
slower than non-verbose.

the first implementation tried to take the tablenames/colums as keys
for the returned json fields, but that doesn't quite work for
patientpsn, where the key would be just 'idcontainer.psn'. so maybe
rename the joined-in fields to sampleid, *_code, patientid,
parentid etc.

``/sample: #py
    def sample(self, sampleids=None, idc=None, patientids=None, locationpaths=None, trials=None, kitids=None, cxxkitids=None, dtypes=None, verbose=[], verbose_all=False, like=[], missing=False, where=None, order_by=None, top=None, print_query=False):
        ``.``
``

these are all possible verbose options (verbose-all-array).

let sampleid be the first element in vaa so it gets joined in first
for subsequent joins that depend on it.

`` #py
        # print("try:" + tr.sampleid)
        vaa = [sampleid, cxxkitid, kitid, locationname, locationpath, orgunit_code, parentid,
               patientid, project_code, receptacle_code, sampletype_code,
               secondprocessing_code, stockprocessing_code, trial_code]
``

always join in the sampleid for now, again, as the first array element
for subsequent joins that might need it.

`` #py
        if not sampleid in verbose:
            verbose.insert(0, sampleid)
``

put the keys for the given arguments into the verbose array, so that
they land in the join, so that the wherestring can access the
joined-in fields.

`` #py
        if patientids:
            verbose.append(patientid)
        if trials:
            verbose.append(trial_code)
        if locationpaths:
            verbose.append(locationpath)
        if kitids:
            verbose.append(kitid)
        if cxxkitid:
            verbose.append(cxxkitid)
``

on verbose_all include all constants in the verbose array.

`` #py
        if verbose_all == True:
            verbose = vaa
``

make sure that the verbose array only contains keys from the verbose-all-array, and possible idcontainer names.

``
        if not _checkverbose(verbose, vaa + self.settings["idc"]):
            return None # throw error?
``

the select statements for optional joins by key.

`` #py
        selects = {
            cxxkitid: [f"samplekit.cxxkitid as '{cxxkitid}'"],
            sampleid: [f"sidc.psn as '{sampleid}'"],
            parentid: [f"parentidc.psn as '{parentid}'"],
            kitid: [f"samplekit.kitid as '{kitid}'"],
            locationname: [f"samplelocation.locationid as '{locationname}'"], 
            locationpath: [f"samplelocation.locationpath as '{locationpath}'"],
            sampletype_code: [f"sampletype.code as '{sampletype_code}'"],
            stockprocessing_code: [f"stockprocessing.code as '{stockprocessing_code}'"],
            secondprocessing_code: [f"secondprocessing.code as '{secondprocessing_code}'"],
            project_code: [f"project.code as '{project_code}'"],
            patientid: [f"patidc.psn as '{patientid}'"],
            receptacle_code: [f"receptable.code as '{receptacle_code}'"],
            orgunit_code: [f"organisationunit.code as '{orgunit_code}'"],
            trial_code: [f"flexistudy.code as '{trial_code}'"],
        }
``

the join statements for optional joins by key. if the same join is
needed for two different keys (e.g. locationname and locationpath),
filter them out later.

pull the values from the join dict, jd.

`` #py
        joins = {
            sampleid: self.jd["sample_to_sampleid"],
            cxxkitid: self.jd["sample_to_samplekit"],
            parentid: self.jd["sample_to_parentid"],
            kitid: self.jd["sample_to_samplekit"],
            locationname: self.jd["sample_to_samplelocation"],
            locationpath: self.jd["sample_to_samplelocation"],
            sampletype_code: self.jd["sample_to_sampletype"],
            stockprocessing_code: self.jd["sample_to_stockprocessing"],
            secondprocessing_code: self.jd["sample_to_secondprocessing"],
            project_code: self.jd["sample_to_project"],
            patientid: self.jd["sample_to_patientid"],
            receptacle_code: self.jd["sample_to_receptacle"],
            orgunit_code: self.jd["sample_to_orgunit"],
            trial_code: self.jd["sample_to_trial"]
        }
``

put together the select string and join string for the query.

`` #py
        selectstr = self._selectstr(selects, verbose, ["sample.*"], idc)  
        joinstr = self._joinstr(joins, verbose, idc)  
``

get the where string.

`` #py
        (wherestr, whereargs) = self._where(sampleids=sampleids, idc=idc, patientids=patientids, trials=trials, locationpaths=locationpaths, kitids=kitids, cxxkitids=cxxkitids, dtypes=dtypes, verbose=verbose, like=like, wherearg=where) 
``

get the top string.

``
        topstr = self._top(top)
``

stick together the query, get the result and return it.

`` #py
        query = f"select {topstr} {selectstr} from centraxx_sample sample {joinstr} where {wherestr}"
        if order_by is not None:
            query += f" order by {order_by}"
        if print_query:
           print(query)
        #print(whereargs)
        res = self.db.qfad(query, whereargs)

        return res
``

the joindict entries that sample needs.

``/jd/sample_to:
            "sample_to_sampleid": ["inner join centraxx_sampleidcontainer as sidc on sidc.sample = sample.oid"],
            "sample_to_samplekit": ["left join centraxx_samplekititem as samplekititem on samplekititem.tubebarcode = sidc.psn", "left join centraxx_samplekit as samplekit on samplekit.oid = samplekititem.samplekit"],                  
            "sample_to_parentid": ["left join centraxx_sampleidcontainer parentidc on parentidc.sample = sample.parent"],
            "sample_to_samplelocation": ["left join centraxx_samplelocation samplelocation on samplelocation.oid = sample.samplelocation"],
            "sample_to_sampletype": ["left join centraxx_sampletype as sampletype on sampletype.oid = sample.sampletype"],
            "sample_to_stockprocessing": ["left join centraxx_stockprocessing as stockprocessing on sample.stockprocessing = stockprocessing.oid"],
            "sample_to_secondprocessing": ["left join centraxx_stockprocessing as secondprocessing on sample.secondprocessing = secondprocessing.oid"],
            "sample_to_project": ["left join centraxx_project as project on sample.project = project.oid"],
            "sample_to_patientid": ["left join centraxx_patientcontainer as patientcontainer on sample.patientcontainer = patientcontainer.oid",
            "left join centraxx_idcontainer as patidc on patidc.patientcontainer = patientcontainer.oid"], 
            "sample_to_receptacle": ["left join centraxx_samplereceptable as receptable on sample.receptable = receptable.oid"], # receptable seems to be a typo in the table naming
            "sample_to_orgunit": ["left join centraxx_organisationunit as organisationunit on sample.orgunit = organisationunit.oid"],
            "sample_to_trial": ["left join centraxx_flexistudy as flexistudy on sample.flexistudy = flexistudy.oid"]
``



patient gives patients.

``/patient: #py
    def patient(self, patientids=None, trials=None, orgunits=None, idc=None, verbose=[], verbose_all=False, like=[], order_by=None, top=None, print_query=False):
        ``.``
``

vaa (verbose-all-array) holds all possible verbose options for patient.

make patientid the first element in vaa so it gets joined in first if
subsequent joins need it.


`` #py
        # print("try:" + tr.sampleid)
        vaa = [patientid, trial_code, orgunit_code]
``

always put the patientid into verbose for now, again, as the first array element
for subsequent joins that might need it.

`` #py
        if not patientid in verbose:
            verbose.insert(0, patientid)
``

put the keys for the given arguments into an array for silent joins.

`` #py
        silent = []
        if trials:
            silent.append(trial_code)
        if orgunits:
            silent.append(orgunit_code)
``

if there's idc given, join in the sample, cause idc joins require a
sample connection. is that always true?

``
        if idc:
            silent.append(sampleid)
``

on verbose_all include all constants in the verbose array.

`` #py
        if verbose_all == True:
            verbose = vaa
``

make sure that the verbose array only contains keys from the
verbose-all-array, and possible idcontainer names.

add the sampleid extra cause it strictly isn't allowed as a verbose
flag, but if verbose is used to orchestrate all joins it needs to be
in verbose for idc?

``
        if not _checkverbose(verbose, vaa + self.settings["idc"] + [sampleid]):
            return None # throw error?
``

the select statements for optional joins by key.

`` #py
        selects = {
            patientid: [f"patidc.psn as '{patientid}'"],
            orgunit_code: [f"organisationunit.code as '{orgunit_code}'"],
            trial_code: [f"flexistudy.code as '{trial_code}'"],
        }
``

the join statements for optional joins by key. if the same join is
needed for two different keys they are filtered out later.

pull the values from the join dict, jd.

`` #py
        joins = {
            patientid: self.jd["patient_to_patientid"],
            orgunit_code: self.jd["patient_to_orgunit"],
            sampleid: self.jd["patient_to_sample"] + self.jd["sample_to_sampleid"], # add sample_to_sampleid to not mess up where clause for now
            trial_code: self.jd["patient_to_trial"]
        }
``

put together the select string and join string for the query.

always select patientcontainer. join in verbose and silent.

`` #py
        selectstr = self._selectstr(selects, verbose, ["patientcontainer.*"], idc)  
        joinstr = self._joinstr(joins, verbose + silent, idc)  
``

get the where string.

`` #py
        (wherestr, whereargs) = self._where(patientids=patientids, trials=trials, idc=idc, verbose=verbose, like=like) 
``

get the top string.

``
        topstr = self._top(top)
``

stick together the query. select distinct so that sample joins for
idcontainers etc don't result in a patient getting returned multiple
times if there's multiple samples.


`` #py
        query = f"select distinct {topstr} {selectstr} from centraxx_patientcontainer patientcontainer {joinstr} where {wherestr}"
        if order_by is not None:
            query += f" order by {order_by}"
        if print_query:
           print(query)
``

get the result and return it.

``
        res = self.db.qfad(query, whereargs)
        return res
``

  

the joindict entries that patient needs.

``/jd/patient_to:
            "patient_to_orgunit": ["left join centraxx_patientorgunit patientorgunit on patidc.patientcontainer=patientorgunit.patientcontainer_oid", "left join centraxx_organisationunit organisationunit on patientorgunit.orgunit_oid=organisationunit.oid"],
            "patient_to_patientid": ["left join centraxx_idcontainer patidc on patidc.patientcontainer = patientcontainer.oid"],
            "patient_to_trial": ["left join centraxx_patientstudy as patientstudy on patientstudy.patientcontainer = patientcontainer.oid", "left join centraxx_flexistudy as flexistudy on flexistudy.oid = patientstudy.flexistudy"],
            "patient_to_sample": ["left join centraxx_sample sample on sample.patientcontainer = patientcontainer.oid"]
``


trial gives trials.

``/trial: #py
    def trial(self):
        ``.``
``

return the trial codes for now.

``
        query = "select code from centraxx_flexistudy"
        res = self.db.qfad(query)
        return res
``

finding gets the laborfinding (messbefund / begleitschein) for
sampleid or messbefund.  (if verbose with its recorded values?)

``/finding: #py
    def finding(self, sampleids=None, methods=None, trials=None, patientids=None, verbose=[], verbose_all=False):
        ``findings``
        ``values``
        ``ret``
``

stick together the query.

``/finding/findings: #py
        query = f"""select laborfinding.oid as "laborfinding_oid", laborfinding.*, labormethod.code as {method_code}, sidc.psn as {sampleid}
        from centraxx_laborfinding as laborfinding

        -- go from laborfinding to sample
        left join centraxx_labormethod as labormethod on laborfinding.labormethod = labormethod.oid
        left join centraxx_labormapping as labormapping on labormapping.laborfinding = laborfinding.oid
        left join centraxx_sample sample on labormapping.relatedoid = sample.oid
        left join centraxx_sampleidcontainer sidc on sidc.sample = sample.oid"""
``

maybe verbose:

always join in the sampleid, that also joins in the method.

        if not sampleid in verbose:
            verbose.append(sampleid)

if trials:
  verbose.append(trial_code)
if patientids:
  verbose.append(patientid)
#if modules:
#  verbose.append(module)
#if tiers:
#  verbose.append(tier)



maybe joins:

joins = {
  sampleid: jd["laborfinding_to_sampleid"], # a bit redundant, but maybe more concise than laborfinding_to_sample followed by sample_to_sampleid?
  trial: jd["sample_to_trial"],
  module: jd["sample_to_module"],
  tier: jd["sample_to_tier"],
  patientid: jd["sample_to_patientid"]
}

get the where string and append it to the query.

``
        (wherestr, whereargs) = self._where(sampleids=sampleids, methods=methods, trials=trials)

        query += " where " + wherestr
        # print(query)
``

get the result.

``
        findings = self.db.qfad(query, whereargs)
``

for each of the findings, pull in the recorded values.

maybe only on --verbose = ["values"]

``/finding/values:
        for i, finding in enumerate(findings):
            ``query``
            ``put``
``

construct the query for the recorded values.

``/finding/values/query:
            query = """select recordedvalue.*, laborvalue.code as laborvalue_code
                from centraxx_laborfinding as laborfinding

                -- go from laborfinding to recorded value
                join centraxx_labfindinglabval as labfindinglabval on labfindinglabval.laborfinding = laborfinding.oid
                join centraxx_recordedvalue as recordedvalue on labfindinglabval.oid = recordedvalue.oid

                --go from labfindinglabval to the laborvalue for the messparam
                join centraxx_laborvalue laborvalue on labfindinglabval.laborvalue = laborvalue.oid

                where laborfinding.oid = ?
            """
``

key the values by laborvalue_code (the messparam name).

``
            vals = self.db.qfad(query, finding['laborfinding_oid'])
            valsbycode = {}
            for val in vals:
              valsbycode[val["laborvalue_code"]] = val
``

put the values to the finding.

``/finding/values/put:
            findings[i][values] = valsbycode
``

return the findings with their respective values.

``/finding/ret:
        return findings
``

labval gets laborvalues (messparameter) of a method.
        
``/labval:
    def labval(self, methods=None):
        ``.``
``

the query.

``
        query = f"""select labval.*, method.code
from centraxx_labormethod method
inner join centraxx_crftemplate crf_t
    on method.crf_template=crf_t.oid
inner join centraxx_crftempsection crf_ts
    on crf_t.oid=crf_ts.crftemplate
inner join centraxx_crftempsection_fields crf_tsf
    on crf_ts.oid=crf_tsf.crftempsection_oid
inner join centraxx_crftempfield crf_tf
    on crf_tsf.crftempfield_oid=crf_tf.oid
inner join centraxx_laborvalue labval
    on crf_tf.labval=labval.oid"""
``

add the where string.

``
        (wherestr, whereargs) = self._where(methods=methods)

        query += " where " + wherestr
``

return the result.

``
        res = self.db.qfad(query, whereargs)

        return res
``

name gives the multilingual names for a code or all codes in a table.

the result is keyed by code and language like this:

"NUM_NMR_ISOLEUCINE_VALUE": {
   "de": "Isoleucin",
   "en": "Isoleucine"
}

table: the name of the centraxx table without centraxx_ prefix
code: a specific code, if none given, all code - name mappings for table are given
lang: de|en
ml_table: if the name of the table connecting to multilingualentry is not simlpy the queried table name followed by "_ml_name", give the connecting table's name here. eg: name('laborvaluegroup', ... ml_name='labval_grp_ml_name')


``/name:
    def name(self, table:str, code:str=None, lang:str=None, ml_table:str=None):
        ``.``
``

interlacing the table name assumes that the referencing pattern for multilingual entries stays the same across table names.

``
        query = "select [" + table + "].code, multilingual.value as name, multilingual.lang as lang"
        query += " from [centraxx_" + table + "] as [" + table + "]"
``

put together the name for the ml_table.

``
        ml_name = ""
        if ml_table != None: # the name is different
            ml_name = "centraxx_" + ml_table
        else: # the name is the same
            ml_name = "centraxx_" + table + "_ml_name"
``

add it to the query.

``
        query += " inner join [" + ml_name + "] mlname on mlname.related_oid = [" + table + "].oid"
        query += " inner join centraxx_multilingualentry multilingual on mlname.oid = multilingual.oid"
``

restrict the query to specific lang or code if given.

``
        wherestrings = []
        args = []
        if code != None:
            wherestrings.append(self._whereparam("[" + table + "].code"))
            args.append(code)
        if lang != None:
            wherestrings.append(self._whereparam("multilingual.lang"))
            args.append(lang)
``

only add sql-where if needed

``
        if len(wherestrings) > 0:
            query += " where "
            # join where clauses by and
            query += " and ".join(wherestrings)

        # print(query)
``

query.

``
        res = self.db.qfad(query, *args)
``

structure by code and lang and return.

``
        out = {}
        for line in res:
            code = line["code"]
            lang = line["lang"]
            if not code in out:
               out[code] = {}
            out[code][lang] = line["name"]
        return out
``

_selectstr filters the selects by the verbose array and returns the
sql select string. selecta is for fields that should be selected
regardless if they're in the verbose array or not.

the idc argument assumes that the sample table is joined it.

``/_selectstr: #py
    def _selectstr(self, selects, verbose, selecta, idc):
        for verb in verbose:
            ``.``        
``

skip verbose entries that are not in the selects dict, they are
probably idc selects that are handled later.

``
            if not verb in selects:
                continue
``

put in the select line(s).

``
            for s in selects[verb]:
                selecta.append(s)
``

append idc selects.

``/_selectstr #py
        selecta = self._append_idc_select(selecta, idc, verbose)
``      

get the selections and joins as string.

`` #py
        selectstr = ", \n".join(selecta)
        return selectstr
``

_joinstr filters the joins by the verbose array and returns the sql join string.

the idc argument assumes that the sample table is joined in.

``/_joinstr: #py
    def _joinstr(self, joins, verbose, idc):
        joina = []
        for verb in verbose:
            ``.``
``


skip verbose entries that are not in the joins dict, they are
probably idc joins that are handled later.

``
            if not verb in joins:
                continue
``

put in the join line(s). make sure that join clauses aren't included
double, for example both locationpath and locationname join in
samplelocation, so check that it's not already in the join array.

``
            for s in joins[verb]:
                if not s in joina:
                    joina.append(s)
``


append idc joins.

``/_joinstr
        joina = self._append_idc_join(joina, idc, verbose)
``      

get the joins as string.

`` #py
        joinstr = "\n ".join(joina)
        return joinstr
``

_append_idc_select adds the sql select statements for an idc dict.

``/_append_idc_select:
    def _append_idc_select(self, selecta, idc, verbose):
      ``.``
``

put in the members of verbose touched by idc.

``
  idca = []
  for verb in verbose:
    if verb in self.settings["idc"]:
      idca.append(verb)
``    

make select strings and append them.

``
  for item in idca:
    selectstr = f"idc_{item}.psn as '{item}'"
    if not selectstr in selecta:
      selecta.append(selectstr)
``

return the selecta with appended strings.

``
  return selecta
``

_append_idc_join adds the sql join statements for an idc dict.

``/_append_idc_join: #py
    def _append_idc_join(self, joina, idc, verbose):
      ``.``
``

put in the members of verbose touched by idc and the keys of idc into
a common array.

``
      idca = []
      for verb in verbose:
        if verb in self.settings["idc"]:
          idca.append(verb)
      if idc is not None:                                
        idca.extend(idc.keys())
``    

add a join for each member of the idc array.

the joins are different for idckind SAMPLE and PATIENT.

``
      for item in idca:
        if self._idckind[item] == "SAMPLE":
          ``sample``
        elif self._idckind[item] == "PATIENT":
          ``patient``
        else:
          print(f"error: idcontainer kind {self._idckind[item]} not supported.")
``

join in sampleidcontainer for SAMPLE. prefix it with idc_ instead of sidc_,
so that there can be one where-check that uses the idc_ prefix for both patient and sample idcontainers.

``./sample:
        joinstr = f"inner join centraxx_sampleidcontainer as idc_{item} on idc_{item}.sample = sample.oid"
        if not joinstr in joina:
          joina.append(joinstr)
``

join in idcontainer via patientcontainer for PATIENT:

``../patient:
        joinstr = f"left join centraxx_patientcontainer as pc_{item} on sample.patientcontainer = pc_{item}.oid"
        if not joinstr in joina: # neccessary?
          joina.append(joinstr)
        joinstr = f"left join centraxx_idcontainer as idc_{item} on pc_{item}.oid = idc_{item}.patientcontainer"
        if not joinstr in joina: # neccessary?
          joina.append(joinstr)
``

return the selecta with appended strings.

``/_append_idc_join
      return joina
``



_where returns the wherestring and args array for the provided arguments (that are not None).
the user needs to make sure that whatever is referenced here is joined into the query before.
the names are assumed to be the tr constants, like e.g. tr.sampleid.
like is an array of tr constants of the arguments for which we check likeness. we only check likeness for the first passed string of an argument array. if for example like=[tr.locationpath], we check likeness of locationpaths[0]."""

make sure only one of sampleids or extsampleids is passed?

``/_where:
    def _where(self, sampleids=None, idc={}, patientids=None, trials=None, locationpaths=None, kitids=None, cxxkitids=None, dtypes=None, methods=None, like=[], verbose=[], wherearg:str=None): # -> (str, [])
        ``.``
``

put the where-info for each field into wheredict along with the passed arguments.

arr: the array of values to check against
field: the table and field where it should match. 
morewhere: additional where constraints, e.g. idcontainertypes for samples.

``
        wheredict = {
          sampleid: { "arr": sampleids, "field": "sidc.psn", "morewhere": f"sidc.idcontainertype = {self._idcoid[self.settings['sampleid'].lower()]}" }, # pass the idcontainertype check along

          patientid: { "arr": patientids, "field": "patidc.psn", "morewhere": f"patidc.idcontainertype = {self._idcoid[self.settings['patientid'].lower()]}" },
          trial_code: { "arr": trials, "field": "flexistudy.code" },
          locationpath: { "arr": locationpaths, "field": "samplelocation.locationpath" },
          method_code: { "arr": methods, "field": "labormethod.code" },
          kitid: { "arr": kitids, "field": "samplekit.kitid" },
          cxxkitid: { "arr": cxxkitids, "field": "samplekit.cxxkitid" },
          dtype: { "arr": dtypes, "field": "sample.dtype" },
        }
``

add the idcs to the where dict.

there could be items in verbose that are queried via the idc, get them
with the intersection call.

``
        idckeys = [] if idc is None else idc.keys()
        idca = list(idckeys) + list(set(verbose).intersection(self.settings["idc"]))
        for item in idca:
            wheredict[item] = { "arr": idc[item] if item in idc else None, 
                                "field": f"idc_{item}.psn", 
                                "morewhere": f"idc_{item}.idcontainertype = {self._idcoid[item]}"
                             }
``

stick together where clauses and arguments that covers the args that
are not None and the constants in verbose. return the wherestring and
args array.

``
        (wherearr, whereargs) = self._wherebuild(wheredict, like, verbose)

        wherestr = " and ".join(wherearr)
``

add the where string passed as argument.

``
        if wherearg is not None:
           wherestr += " and (" + wherearg + ")"
``

return.

``
        return (wherestr, whereargs)
``

_wherebuild builds wherestrings and fills whereargs.

``/_wherebuild:
    def _wherebuild(self, wheredict, likearr=[], verbose=[]): # ([]string, [])
        ``.``
``

wherestrs and whereargs get filled.

``
        wherestrs = []
        whereargs = []
``

iterate the passed wheredict. key is one of the tr constant strings, e.g. tr.locationpath.

``
        for (key, row) in wheredict.items():
            ``no arr``
            ``like``
            else:
                ``exact``
            ``more where``
``

if there is no search array or it is empty still check for the
morewhere-clause, cause the key could be in verbose, and then the
morewhere-clause would be needed. then skip.


``./no arr:
            if row["arr"] == None or len(row["arr"]) == 0:
                # the key is in the verbose-output selection
                if key in verbose and "morewhere" in row:
                    # we're not searching for specific values, so only add the morewhere clause
                    wherestrs.append(row["morewhere"])
                continue
``

should we check for likeness for this key?

``/_wherebuild/like:
            if likearr is not None and key in likearr: 
                # put in an or-chain of like checks over all elements
                s = "(" + self._wherelikes(row["field"]) + ")"
                wherestrs.append(s)
                whereargs.append(row["arr"])
``

else we search by exact matching.

if we'd like to take NULL checks into account, we need to check it
extra, like '(kitid is NULL or kitid in (1, 2, 3))'.

``/_wherebuild/exact:
                wherestr = "("
``
                
is there a 'NULL' in the array? put in a NULL check and remove it from
the array, so it doesn't mess with the where-arguments later.

``
                needsor = False
                if 'NULL' in row["arr"]:
                    row["arr"].remove("NULL")
                    wherestr += row["field"] + " is NULL"
                    needsor = True
``

if there is anything left in the array, make the in-list part of the
wherestring with the ?-placeholder string.

``
                if len(row["arr"]) > 0:
                    if needsor:
                        wherestr += " or "
                    placeholder = traction._sqlinplaceholder(len(row["arr"])) # todo put in package? tr._sqlinplaceholder
                    wherestr += row["field"] + " in " + placeholder # e.g. samplelocation.locationpath in (?, ?, ?)
``

close the wherestr with ) and put the wherestring and its arguments
into their corresponding arrays.

``
                wherestr += ")"
                wherestrs.append(wherestr)
                whereargs.extend(row["arr"])
``

are there additional where clauses passed (e.g. for idcontainertype)? add them.

``/_wherebuild/more where:
            if "morewhere" in row:
                wherestrs.append(row["morewhere"])
``

out of the loop, return.

``/_wherebuild/
        return (wherestrs, whereargs)
``

    
_sqlinplaceholder returns a string like (?, ?, ?, ? ...) with n question marks for sql in.

``/_sqlinplaceholder:
    def _sqlinplaceholder(n):

        # put this in a package sqlutil?

        out = "("
        for i in range(n):
            out += "?"
            if i < n - 1:
                out += ","
        out += ")"
        return out
``

_whereparam gives a ?-parameterized sql where expression for name
equal or like parameter for use in queries.

``/_whereparam:
    def _whereparam(self, name, like:bool=None):
        if like == None or like == False:
            return name + " = ?"
        else:
            return name + " like '%' + ? + '%'"
``

_wherelike gives a ?-parameterized sql where like expression.

``/_wherelike:
    def _wherelike(self, name):
          return name + " like '%' + ? + '%'"

``

_wherelikes gives a ?-parameterized sql of or-joined where-like expressions.

``/_wherelikes:
    def _wherelikes(self, fieldarr):
        a = []
        for f in fieldarr:
            a.append(f + " like '%' + ? + '%'") # the sql takes literal plusses like here
        return " or ".join(a)
``

_top returns the top string, for, e.g. `select top 100 * from table`, if
top is None return an empty string.

``/_top:
    def _top(self, top):
        if top is not None:
           return f"top {top}"
        return ""
``                             

_idcinit makes a mapping of idcontainers from their code (lower-case) to respective oid and kind.

``/_idcinit:
    def _idcinit(self):
        ``.``
``

get the codes and oids.

``
        query = "select code, oid, kind from centraxx_idcontainertype"
        res = self.db.qfad(query)
``

return idcontainer oids and kinds keyed by their code.

``
        self._idcoid = {}
        self._idckind = {}
        for row in res:
          self._idcoid[row["code"].lower()] = row["oid"]
          self._idckind[row["code"].lower()] = row["kind"]
``

_checkverbose makes shure that only allowed keys are in the verbose array. 

``/_checkverbose:
def _checkverbose(verbose, possible):
        for verb in verbose:
            if not verb in possible: 
                print(f"error: verbose entry {verb} must be in {possible}.")
                return False
        return True
``


_readsettings reads the setting file (and creates it if it's not there).

``/_readsettings:
def _readsettings():
  ``.``
``

if no settings, create stub settings file.

``
  if not _hassettings():
    with open(_settingspath(), "w") as file:
      settingsstr = """
# settings for traction.

# sampleid sets the idcontainertype code that is used when searching for sampleid
sampleid: <an idcontainertype code, e.g. SAMPLEID>
# patientid sets the idcontainertype code that is used when searching for patientid
patientid: <an idcontainertype code, e.g. LIMSPSN>

# idc holds additional idcontainertype codes that will be queryable as command line flags 
idc:
 - <an idcontainertype code>
 - <another idcontainertype code>
"""
      file.write(settingsstr)
      print(f"traction: please edit {_settingspath()} and fill in the idcontainertype codes for sampleid and patientid, then run again.")
      return None
``

else read the settings.

``
  else:
    # read settings file yaml
    with open(_settingspath(), "r") as file:
      settings = yaml.safe_load(file)
      return settings
``

import yaml.

``/import
import yaml
``


settingspath returns the path to the settings.

``/_settingspath:

def _settingspath():
    home = Path.home()
    return home / ".traction" / "settings.yaml"
``

_hassettings reports whether there is a settings file.

``/_hassettings:
def _hassettings():
    return _settingspath().is_file()
``



